1
00:00:00,080 --> 00:00:01,800
본 저작물은 크리에이티브 커먼즈
라이선스를 따르고 있습니다

2
00:00:01,800 --> 00:00:04,040
본 저작물은 크리에이티브 커먼즈
라이선스를 따르고 있습니다

3
00:00:04,040 --> 00:00:06,880
여러분의 후원이 
MIT OpenCourseWare가

4
00:00:06,880 --> 00:00:10,740
지속적으로 고품질의 교육 자료를
무료로 제공하는 데에 큰 도움이 됩니다

5
00:00:10,740 --> 00:00:13,350
후원을 하시거나

6
00:00:13,350 --> 00:00:17,237
더 많은 MIT 강의 자료를 찾으시려면

7
00:00:17,237 --> 00:00:17,862
ocw.mit.edu를 방문해 주세요​

8
00:00:22,460 --> 00:00:24,510
좋은 아침입니다

9
00:00:24,510 --> 00:00:26,740
최단 경로에 관한 네 번의 수업 중
두 번째 수업입니다

10
00:00:26,740 --> 00:00:30,580
최단 경로에 관한 네 번의 수업 중
두 번째 수업입니다

11
00:00:30,580 --> 00:00:34,220
지난 시간에는 최단 경로 알고리즘의
일반적인 구조에 대해 알아보았습니다

12
00:00:34,220 --> 00:00:37,160
지난 시간에는 최단 경로 알고리즘의
일반적인 구조에 대해 알아보았습니다

13
00:00:37,160 --> 00:00:40,022
오늘은 구체적인 알고리즘을
배워보겠습니다

14
00:00:40,022 --> 00:00:44,030
다익스트라 알고리즘입니다

15
00:00:44,030 --> 00:00:45,960
시작하기에 앞서

16
00:00:45,960 --> 00:00:49,610
지난주에 다루었던 몇몇 개념을

17
00:00:49,610 --> 00:00:54,450
복습해보도록 하겠습니다

18
00:00:54,450 --> 00:00:56,590
그중에서도 최단 경로 알고리즘의
기초가 되는 연산인

19
00:00:56,590 --> 00:00:59,425
그중에서도 최단 경로 알고리즘의
기초가 되는 연산인

20
00:00:59,425 --> 00:01:01,630
완화에 대해서 살펴보았었습니다

21
00:01:01,630 --> 00:01:03,680
그에 대해 다시 한번 살펴볼 것입니다

22
00:01:03,680 --> 00:01:06,020
오늘은 최단 경로 알고리즘의
몇 가지 특수한 경우를 다룰 것입니다

23
00:01:06,020 --> 00:01:10,080
오늘은 최단 경로 알고리즘의
몇 가지 특수한 경우를 다룰 것입니다

24
00:01:10,080 --> 00:01:13,440
비순환 방향 그래프를 살펴볼 것인데

25
00:01:13,440 --> 00:01:17,430
이는 순환이 없는 그래프를 말합니다

26
00:01:17,430 --> 00:01:22,770
음의 간선의 존재 여부와 관계없이

27
00:01:22,770 --> 00:01:24,440
DAG에서의 최단 경로를 찾는
직접적인 알고리즘이 있습니다

28
00:01:24,440 --> 00:01:28,760
DAG에서의 최단 경로를 찾는
직접적인 알고리즘이 있습니다

29
00:01:28,760 --> 00:01:30,770
그리고 음의 간선이 없는 경우에
초점을 맞출 것입니다

30
00:01:30,770 --> 00:01:32,660
그리고 음의 간선이 없는 경우에
초점을 맞출 것입니다

31
00:01:32,660 --> 00:01:35,970
그리고 다익스트라 알고리즘에
대해 다루겠습니다

32
00:01:35,970 --> 00:01:43,190
지난 시간 복습부터 해보겠습니다

33
00:01:43,190 --> 00:01:46,330
여기 아주 자명한 예가 하나 있습니다

34
00:01:46,330 --> 00:01:50,000
이 그래프에서
최단 경로를 구한다고 해보죠

35
00:01:50,000 --> 00:01:56,780
각 정점 안에 적힌 수는 우선순위입니다

36
00:01:56,780 --> 00:01:58,320
각 정점 안에 적힌 수는 우선순위입니다

37
00:01:58,320 --> 00:02:09,720
d[v]를 출발점 s부터 v까지의
현재 최단 경로의 길이라고 생각합시다

38
00:02:09,720 --> 00:02:16,250
d[v]를 출발점 s부터 v까지의
현재 최단 경로의 길이라고 생각합시다

39
00:02:16,250 --> 00:02:22,900
그리고 출발점 s로부터
s까지의 거리는 0이므로

40
00:02:22,900 --> 00:02:24,130
d[s]는 0입니다

41
00:02:24,130 --> 00:02:26,590
0으로 시작해서 0으로 끝납니다

42
00:02:26,590 --> 00:02:29,940
나머지는 무한대로 초기화됩니다

43
00:02:29,940 --> 00:02:35,180
그리고 완화라고 불리는
과정을 진행하면서

44
00:02:35,180 --> 00:02:40,770
이 d 값들을 줄여나가게 될 것입니다

45
00:02:40,770 --> 00:02:42,930
지금까지 최단 경로의 길이인 이 값을

46
00:02:42,930 --> 00:02:49,575
δ라고 불리는 값이 될 때까지
줄일 것입니다

47
00:02:49,610 --> 00:02:57,000
실제 최단 경로의 길이 말이죠

48
00:02:57,040 --> 00:02:58,065
유일할 수도 있고

49
00:02:58,065 --> 00:02:59,750
유일하지 않을 수도 있습니다

50
00:02:59,750 --> 00:03:02,280
하지만 최솟값을 구해야 합니다

51
00:03:02,280 --> 00:03:09,330
모든 정점에서 점점 수렴하는

52
00:03:09,330 --> 00:03:11,710
d 값이 δ로 수렴했을 때

53
00:03:11,710 --> 00:03:14,120
알고리즘은 끝나게 됩니다

54
00:03:14,120 --> 00:03:19,490
마지막으로 경로를
복원하기 위해 중요한 점은

55
00:03:19,490 --> 00:03:26,900
선행자라는 개념입니다

56
00:03:26,900 --> 00:03:36,530
∏[v]는 s부터 v까지의 최단 경로에서
v의 선행자를 의미합니다

57
00:03:36,530 --> 00:03:44,180
이 선행 관계를 따라가면

58
00:03:44,180 --> 00:03:46,810
최단 경로를 재구성할 수 있습니다

59
00:03:46,810 --> 00:03:51,560
모든 값이 δ(s, v)로
수렴하고 난 뒤에 말입니다

60
00:03:51,560 --> 00:03:57,140
이 자명한 예에서는

61
00:03:57,140 --> 00:04:04,580
d[S]가 0이고 d[A]와 d[B]가
무한대인 것에서 시작합니다

62
00:04:04,580 --> 00:04:10,560
여기 가중치를 추가하겠습니다

63
00:04:10,560 --> 00:04:13,520
그리고 s에서 나가는 간선들에 대해서
완화를 하면 됩니다

64
00:04:13,520 --> 00:04:16,510
그리고 s에서 나가는 간선들에 대해서
완화를 하면 됩니다

65
00:04:16,510 --> 00:04:19,488
완화에 대해서는 잠시 후에
공식적으로 살펴 보겠지만

66
00:04:19,488 --> 00:04:21,940
지난 시간에 보았던 것과 마찬가지로

67
00:04:21,940 --> 00:04:24,180
이 간선을 따라가면서

68
00:04:24,180 --> 00:04:26,710
d[A] 값을 갱신하는 과정입니다

69
00:04:26,710 --> 00:04:30,140
그러면 이 무한대가 1이 되겠죠

70
00:04:30,140 --> 00:04:33,590
여기서 0으로 시작해서 1을 더하면
여기는 1이 되기 때문입니다

71
00:04:33,590 --> 00:04:35,830
그와 비슷하게
이 무한대는 3이 됩니다

72
00:04:35,830 --> 00:04:38,100
여기까지 S에서 A와 B로 나가는
간선들에 대해 완화를 한 것입니다

73
00:04:38,100 --> 00:04:43,040
여기까지 S에서 A와 B로 나가는
간선들에 대해 완화를 한 것입니다

74
00:04:43,040 --> 00:04:45,532
아직 끝난 것은 아닙니다

75
00:04:45,532 --> 00:04:49,770
적어도 이 예제의 지금 시점에서

76
00:04:49,770 --> 00:04:52,350
A로 가는 최단 경로는 찾았다고
생각할 수 있습니다

77
00:04:52,350 --> 00:04:57,940
하지만 B로 가는 경로는
거리 2의 길이 있습니다

78
00:04:57,940 --> 00:05:01,540
지금까지의 B로 가는 최단 경로는

79
00:05:01,540 --> 00:05:05,500
첫 단계로 S에서 나가는
간선에 대해 완화한 후에

80
00:05:05,500 --> 00:05:06,720
3이었습니다

81
00:05:06,720 --> 00:05:13,360
하지만 이렇게 간다면
2를 얻을 수 있습니다

82
00:05:13,360 --> 00:05:15,790
이 시점에서 끝나게 됩니다

83
00:05:15,790 --> 00:05:20,380
이제 저희는 저희가 볼
모든 알고리즘에 대해

84
00:05:20,380 --> 00:05:24,760
δ로 수렴하며 종료한다는 것을
보여야 합니다

85
00:05:24,760 --> 00:05:25,374
δ로 수렴하며 종료한다는 것을
보여야 합니다

86
00:05:25,374 --> 00:05:27,790
또한 알고리즘의 점근적 복잡도를
생각해봐야 할 것입니다

87
00:05:27,790 --> 00:05:28,930
또한 알고리즘의 점근적 복잡도를
생각해봐야 할 것입니다

88
00:05:28,930 --> 00:05:31,060
하지만 일반적인 흐름은 이렇습니다

89
00:05:31,060 --> 00:05:34,060
오늘은 예고했던 대로
두 알고리즘을 배울 것입니다

90
00:05:34,060 --> 00:05:35,520
두 경우 모두 특수한 경우입니다

91
00:05:35,520 --> 00:05:38,380
하나는 DAG일 때이고
다른 하나 음의 간선이 없을 때입니다

92
00:05:38,380 --> 00:05:41,430
그리고 엄밀한 증명을 하지는 않겠지만

93
00:05:41,430 --> 00:05:44,320
강한 직감으로 알고리즘이
왜 작동하는지 알게 될 것입니다

94
00:05:44,320 --> 00:05:46,990
강한 직감으로 알고리즘이
왜 작동하는지 알게 될 것입니다

95
00:05:46,990 --> 00:05:52,750
배울 내용에 대해 질문 있나요?

96
00:05:52,750 --> 00:05:54,920
좋습니다

97
00:05:54,920 --> 00:05:58,220
그러면 왜 완화 과정이 유용한지

98
00:05:58,220 --> 00:06:04,770
그러면 왜 완화 과정이 유용한지

99
00:06:04,770 --> 00:06:08,470
그리고 더 중요하게 왜 안전하고
정확한지 알아보겠습니다

100
00:06:08,470 --> 00:06:15,220
기본적인 완화 연산에 대해
떠올려보겠습니다

101
00:06:15,220 --> 00:06:19,740
여기서 무한대를 1로, 3을 2로
갱신하는 등의 작업이죠

102
00:06:19,740 --> 00:06:24,100
여기서 무한대를 1로
3을 2로 갱신하는 등의 작업이죠

103
00:06:24,100 --> 00:06:33,510
d[v]가 d[u] + w(u, v)보다 크다면

104
00:06:33,510 --> 00:06:40,100
d[v]를 d[u] + w(u, v)로
갱신합니다

105
00:06:40,100 --> 00:06:44,070
정점 v로 가는 더 나은 길을
발견했기 때문이죠

106
00:06:44,070 --> 00:06:48,505
더 짧은 길 말입니다

107
00:06:48,560 --> 00:06:51,920
그리고 이 길은
u를 거쳐 가는 길이므로

108
00:06:51,920 --> 00:06:55,330
우선순위만 바꾸는 것이 아니고

109
00:06:55,330 --> 00:06:57,450
선행 관계도 바꾸어 주어야 합니다

110
00:06:57,450 --> 00:06:57,950
그렇습니다

111
00:06:57,950 --> 00:06:59,940
이것이 완화 단계입니다

112
00:06:59,940 --> 00:07:04,805
이제는 이 완화 과정이
안전한지 보여야 합니다

113
00:07:10,200 --> 00:07:11,760
안전하다는 것이 무슨 뜻일까요?

114
00:07:11,760 --> 00:07:16,470
어떤 특정한 간선에 대해
완화를 했는데

115
00:07:16,470 --> 00:07:18,490
그것이 잘못된 결과를 이끌어

116
00:07:18,490 --> 00:07:23,320
δ(s, v)보다 더 작은 값을 얻어낼
가능성이 없는지 확인해봐야 합니다

117
00:07:23,320 --> 00:07:25,880
저희는 이 값이 큰 값에서부터
수렴하기를 원합니다

118
00:07:25,880 --> 00:07:28,840
처음에는 무한대의 값에서 시작하여

119
00:07:28,840 --> 00:07:31,660
그 정점으로 가는 경로를
모르기 때문입니다

120
00:07:31,660 --> 00:07:35,700
그 값을 계속해서
줄여나가는 것이죠

121
00:07:35,700 --> 00:07:39,459
그렇게 옳은 δ 값으로 수렴하면

122
00:07:39,459 --> 00:07:40,750
더 진행하면 안 됩니다

123
00:07:40,750 --> 00:07:41,470
그렇죠?

124
00:07:41,470 --> 00:07:44,130
만약에 작은 값을 얻었다면

125
00:07:44,130 --> 00:07:46,170
다시 올라가는 방법에 대해
생각해보아야 하는데

126
00:07:46,170 --> 00:07:49,630
저희가 원하는 알고리즘은
그런 종류가 아닙니다

127
00:07:49,630 --> 00:07:51,960
최소한 여기서 이야기하고 있는
알고리즘은 말입니다

128
00:07:51,960 --> 00:07:53,930
그런 상황은 위험하죠

129
00:07:53,930 --> 00:07:56,850
그래서 완화 과정이 안전하길 원합니다

130
00:07:56,850 --> 00:08:02,510
귀납법을 이용하면 간단한
보조 정리를 증명할 수 있는데

131
00:08:02,510 --> 00:08:10,280
귀납법을 이용하면 간단한
보조 정리를 증명할 수 있는데

132
00:08:10,280 --> 00:08:13,690
어떠한 순서로 완화를 하든
상관없음을 보일 수 있습니다

133
00:08:13,690 --> 00:08:15,690
어떠한 순서로 완화를 하든
상관없음을 보일 수 있습니다

134
00:08:15,690 --> 00:08:17,595
이 보조 정리는 꽤 강력합니다

135
00:08:17,595 --> 00:08:20,850
완화 과정이 있는 알고리즘에서

136
00:08:20,850 --> 00:08:25,850
d 값을 갱신하는 방법이
완화 과정으로 유일하다면

137
00:08:25,850 --> 00:08:27,560
안전하다는 것을 보여줍니다

138
00:08:27,560 --> 00:08:30,934
잘못된 최단 경로가
나오지 않는다는 것입니다

139
00:08:30,934 --> 00:08:32,350
알고리즘의 끝에서도

140
00:08:32,350 --> 00:08:35,299
실행 중의 어떤 시점에서도

141
00:08:35,299 --> 00:08:36,409
안전하다는 것입니다

142
00:08:36,409 --> 00:08:36,909
알겠나요?

143
00:08:36,909 --> 00:08:39,890
완화 연산을 해도

144
00:08:39,890 --> 00:08:53,160
모든 정점에 대해 d[v]가 δ(s, v)보다
크거나 같다는 사실은 변하지 않는다

145
00:08:53,160 --> 00:09:02,310
모든 정점에 대해 d[v]가 δ(s, v)보다
크거나 같다는 사실은 변하지 않는다

146
00:09:02,310 --> 00:09:03,230
알겠죠?

147
00:09:03,230 --> 00:09:05,376
정말 강력한 정리이죠

148
00:09:05,376 --> 00:09:07,250
증명이 뻔히 보이지만

149
00:09:07,250 --> 00:09:09,750
중요한 정리입니다

150
00:09:09,750 --> 00:09:13,330
이 정리는 우리가 지난주에
이야기하였던 최단 경로 알고리즘의

151
00:09:13,330 --> 00:09:16,480
일반적인 구조를 만들 수 있음을
이야기해 줍니다

152
00:09:16,480 --> 00:09:19,370
간선을 하나 선택하고

153
00:09:19,370 --> 00:09:20,311
완화하고

154
00:09:20,311 --> 00:09:21,060
또 다른 간선을 선택하고

155
00:09:21,060 --> 00:09:21,997
완화하고

156
00:09:21,997 --> 00:09:23,580
그러면 잘 작동해서

157
00:09:23,580 --> 00:09:25,480
δ 값을 얻을 수 있기를 바라는 거죠

158
00:09:25,480 --> 00:09:28,927
이 보조 정리가 말하는 것은

159
00:09:28,927 --> 00:09:30,510
이 과정의 중간에서

160
00:09:30,510 --> 00:09:32,500
최단 경로의 길이보다 짧은 것이
나오지 않는다는 것입니다

161
00:09:32,500 --> 00:09:35,780
그리고 이 과정을 충분히 긴 시간 동안 반복하게 된다면

162
00:09:35,780 --> 00:09:37,440
간선을 선택하는 특정한
경험적 방법에 따라

163
00:09:37,440 --> 00:09:39,560
간선을 선택하는 특정한
경험적 방법에 따라

164
00:09:39,560 --> 00:09:41,570
알고리즘이 최종적으로 종료하게 되겠죠

165
00:09:41,570 --> 00:09:46,740
이 과정이 다항 시간 안에
이루어지면 좋겠습니다

166
00:09:46,740 --> 00:09:50,500
그러면 이를 어떻게 증명할까요?

167
00:09:50,500 --> 00:09:52,620
절반 정도를 같이 증명하고

168
00:09:52,620 --> 00:09:56,160
마무리는 여러분들이
하는 것으로 하겠습니다

169
00:09:56,160 --> 00:10:04,640
과정의 횟수에 대해
수학적 귀납법을 이용하겠습니다

170
00:10:04,640 --> 00:10:14,920
d[u]가 δ(s, u)보다 크거나
같을 것이라고 가정하겠습니다

171
00:10:14,920 --> 00:10:23,950
d[u]가 δ(s, u)보다 크거나
같을 것이라고 가정하겠습니다

172
00:10:23,950 --> 00:10:28,850
그리고 완화를 할 것입니다

173
00:10:28,850 --> 00:10:36,680
이것이 맞는다는 것이
기본 단계가 되겠죠

174
00:10:36,690 --> 00:10:43,450
이제 저희가 보이고 싶은 것은 완화 과정이
d[v]를 틀리게 만들지 않는다는 것입니다

175
00:10:43,450 --> 00:10:47,090
이제 저희가 보이고 싶은 것은 완화 과정이
d[v]를 틀리게 만들지 않는다는 것입니다

176
00:10:47,090 --> 00:10:53,365
이것이 귀납 가정입니다

177
00:10:54,660 --> 00:11:00,680
삼각 부등식에 의해

178
00:11:00,680 --> 00:11:05,590
삼각 부등식은 지난주
수업 때 다루었었죠

179
00:11:05,590 --> 00:11:12,050
δ(s, v)가 δ(s, u) + δ(u, v)보다
작거나 같게 됩니다

180
00:11:12,050 --> 00:11:17,000
δ(s, v)가 δ(s, u) + δ(u, v)보다
작거나 같게 됩니다

181
00:11:17,000 --> 00:11:26,670
이가 의미하는 것은
이런 경로가 있을 때

182
00:11:26,670 --> 00:11:30,340
s가 있고

183
00:11:30,340 --> 00:11:35,570
각각 u와 v라고 하겠습니다

184
00:11:35,570 --> 00:11:38,970
이것은 s와 v 사이의
간선이 아닌 경로입니다

185
00:11:38,970 --> 00:11:40,340
하나의 간선이 될 수도 있지만

186
00:11:40,340 --> 00:11:43,510
이를 s와 v 사이의 경로라고
생각하겠습니다

187
00:11:43,510 --> 00:11:47,030
이것은 s와 u 사이의 경로이고

188
00:11:47,030 --> 00:11:50,890
이는 u와 v 사이의 경로입니다

189
00:11:50,890 --> 00:11:55,080
그리고 특별히

190
00:11:55,080 --> 00:12:07,280
s에서 u로 그리고 u에서 v로 가는 것이

191
00:12:07,280 --> 00:12:12,980
s에서 v로 가는
최선의 경로보다 짧다면

192
00:12:12,980 --> 00:12:14,831
이는 모순이 됩니다

193
00:12:14,831 --> 00:12:15,330
이는 모순이 됩니다

194
00:12:15,330 --> 00:12:21,270
왜냐하면 이것이 s에서 v로 가는
가장 짧은 길이고

195
00:12:21,270 --> 00:12:23,600
포함되어야 하는 간선의 개수에도
제약이 없습니다

196
00:12:23,600 --> 00:12:26,750
포함되어야 하는 간선의 개수에도
제약이 없습니다

197
00:12:26,750 --> 00:12:28,730
그래서 정의에 의해 가장 짧은 길이

198
00:12:28,730 --> 00:12:31,140
s에서 v로 바로 가는 방법과

199
00:12:31,140 --> 00:12:32,460
간선이 하나일 수도 있고요

200
00:12:32,460 --> 00:12:36,611
아니면 정점 u를 거쳐 가는
방법이 있게 됩니다

201
00:12:36,611 --> 00:12:37,110
아니면 정점 u를 거쳐 가는
방법이 있게 됩니다

202
00:12:37,110 --> 00:12:39,890
이것이 삼각 부등식입니다

203
00:12:39,890 --> 00:12:44,160
여기서 했던 것과
조금 다른 것에 주의하세요

204
00:12:44,160 --> 00:12:50,670
여기는 S에서 A를 거쳐
B로 가는 것이

205
00:12:50,670 --> 00:12:53,062
S에서 B로 가는 것보다 짧았습니다

206
00:12:53,062 --> 00:12:55,020
하지만 이것은 하나의 간선과

207
00:12:55,020 --> 00:12:56,220
가중치에 관해서 이야기하고 있습니다

208
00:12:56,220 --> 00:12:57,880
그래서 여기는 모순이 없습니다

209
00:12:57,880 --> 00:13:01,930
여기서 보고 싶은 것은

210
00:13:01,930 --> 00:13:07,470
δ(S, B)가 2가 되는 것입니다

211
00:13:07,470 --> 00:13:08,840
δ(S, B)가 2가 되는 것입니다

212
00:13:08,840 --> 00:13:11,310
처음에는 d 값이
무한대와 3일 수 있지만

213
00:13:11,310 --> 00:13:12,900
처음에는 d 값이
무한대와 3일 수 있지만

214
00:13:12,900 --> 00:13:15,980
δ 값은 B로 가는 최단 경로이고

215
00:13:15,980 --> 00:13:17,510
A를 거쳐 가는 것이 되게 됩니다

216
00:13:17,510 --> 00:13:20,150
그래서 이를 이용하면
삼각 부등식이 성립하게 됩니다

217
00:13:20,150 --> 00:13:21,060
그래서 이를 이용하면
삼각 부등식이 성립하게 됩니다

218
00:13:21,060 --> 00:13:24,760
이런 그림을 볼 때 헷갈리지 마세요

219
00:13:24,760 --> 00:13:29,020
가중치는 삼각 부등식을 따르지 않습니다

220
00:13:29,020 --> 00:13:30,040
가중치는 삼각 부등식을 따르지 않습니다

221
00:13:30,040 --> 00:13:33,160
삼각 부등식은
최단 경로를 이야기하는 것이지

222
00:13:33,160 --> 00:13:35,101
단일 간선을 이야기하는 것이 아닙니다

223
00:13:35,101 --> 00:13:36,490
알겠나요?

224
00:13:38,410 --> 00:13:42,320
여기까지가 증명의 절반입니다

225
00:13:42,320 --> 00:13:46,790
제가 한 것은
d[u]가 맞을 것이라고 가정하고

226
00:13:46,790 --> 00:13:50,060
삼각 부등식을 이용했습니다

227
00:13:50,060 --> 00:13:51,680
그리고 그냥 적었죠

228
00:13:51,680 --> 00:13:58,200
그리고 한 분이
나머지 증명을 하면 되겠습니다

229
00:13:58,200 --> 00:13:59,730
그리고 한 분이
나머지 증명을 하면 되겠습니다

230
00:13:59,730 --> 00:14:01,500
하실 분 있나요?

231
00:14:03,100 --> 00:14:05,800
이 주어진 값을 보고
제가 여기서 말할 수 있는 것은

232
00:14:05,800 --> 00:14:09,080
이 두 값을 보고

233
00:14:09,080 --> 00:14:12,620
어떤 말을 할 수 있을까요?

234
00:14:12,620 --> 00:14:14,520
어떻게 증명을 할 수 있을까요?

235
00:14:14,520 --> 00:14:19,750
δ(s, v)가 d[v]보다
작거나 같음을 보여야 합니다

236
00:14:19,750 --> 00:14:21,560
δ(s, v)가 d[v]보다
작거나 같음을 보여야 합니다

237
00:14:21,560 --> 00:14:22,190
δ(s, v)가 d[v]보다
작거나 같음을 보여야 합니다

238
00:14:22,190 --> 00:14:24,680
이것이 저희가
보이고자 하는 것입니다

239
00:14:24,680 --> 00:14:26,780
여기서는 조금 다르게 썼을 뿐입니다

240
00:14:26,780 --> 00:14:29,440
어떻게 하면 될까요?

241
00:14:30,946 --> 00:14:36,136
누구 없나요?

242
00:14:36,380 --> 00:14:45,810
어떤 것을 치환할 수 있을까요?
여기에 부등호가 있다는 것은

243
00:14:45,810 --> 00:14:48,830
여기에 있는 것들을
바꿀 수 있다는 뜻이죠

244
00:14:48,830 --> 00:14:49,635
네

245
00:14:49,635 --> 00:14:53,017
학생: 저기 부등식을 이용해서
d[u]를 바꿀 수 있을 것 같습니다

246
00:14:53,017 --> 00:14:53,600
맞습니다

247
00:14:53,600 --> 00:14:54,100
맞습니다

248
00:14:54,100 --> 00:14:59,260
먼저 d[u]를 여기 넣을 수 있겠죠?

249
00:14:59,260 --> 00:15:04,150
d[u]보다 작거나 같다

250
00:15:04,150 --> 00:15:06,110
이렇게 할 수 있는 이유는

251
00:15:06,110 --> 00:15:09,540
d[u]가 δ(s, u)보다 크기 때문입니다

252
00:15:09,540 --> 00:15:13,070
그럼 됐죠

253
00:15:13,070 --> 00:15:13,690
δ네요 죄송합니다

254
00:15:13,690 --> 00:15:14,680
δ네요 죄송합니다

255
00:15:14,680 --> 00:15:15,900
δ(s, u)

256
00:15:15,900 --> 00:15:16,960
감사합니다

257
00:15:16,960 --> 00:15:18,630
그래서 여기까지 할 수 있고

258
00:15:18,630 --> 00:15:20,040
무엇을 더 할 수 있을까요?

259
00:15:20,040 --> 00:15:20,540
네

260
00:15:20,540 --> 00:15:24,030
학생 : δ(u, v)를
w(u, v)로 치환합니다

261
00:15:24,030 --> 00:15:25,990
δ(u, v)를 w(u, v)로 바꾼다

262
00:15:25,990 --> 00:15:28,710
맞습니다

263
00:15:28,710 --> 00:15:29,720
맞습니다

264
00:15:29,720 --> 00:15:30,320
잘했어요

265
00:15:30,320 --> 00:15:31,560
방석을 받을 만하네요

266
00:15:31,560 --> 00:15:33,420
아 이미 가지고 계셨었죠

267
00:15:33,420 --> 00:15:35,041
네

268
00:15:35,041 --> 00:15:35,540
아이고

269
00:15:35,540 --> 00:15:39,030
아 이렇게 하면 안 됐는데
잘못 던졌으니 그냥 가지세요

270
00:15:39,030 --> 00:15:40,930
다시 한번
아이고

271
00:15:40,930 --> 00:15:41,510
네

272
00:15:41,510 --> 00:15:42,520
네

273
00:15:42,520 --> 00:15:44,270
머리를 맞았으니 그냥 가지세요

274
00:15:44,270 --> 00:15:45,190
머리를 맞았으니 그냥 가지세요

275
00:15:45,190 --> 00:15:46,440
그냥 가져다드릴게요

276
00:15:46,440 --> 00:15:47,814
이러다 방석이 부족하겠어요

277
00:15:47,814 --> 00:15:51,890
제 연구실에 더 있습니다

278
00:15:51,890 --> 00:15:52,710
네 그래서

279
00:15:52,710 --> 00:15:53,270
이게 끝입니다

280
00:15:53,270 --> 00:15:54,860
여기까지가 증명입니다

281
00:15:54,860 --> 00:15:56,032
아시겠나요?

282
00:15:56,032 --> 00:15:59,170
꽤 직접적이죠

283
00:15:59,860 --> 00:16:04,290
삼각 부등식을 적용하고 나서

284
00:16:04,290 --> 00:16:07,000
삼각 부등식을 적용하고 나서

285
00:16:07,000 --> 00:16:11,270
각 항을 보면

286
00:16:11,270 --> 00:16:16,350
귀납 가정에 의해
여기에 d[u]를 집어넣을 수 있고

287
00:16:16,350 --> 00:16:18,500
가중치에 대해
이런저런 이야기를 하면서

288
00:16:18,500 --> 00:16:20,480
가중치에 대해
이런저런 이야기를 하면서

289
00:16:20,480 --> 00:16:23,630
w(u, v)가 직접 하나의 간선만을
타고 가는 방법이기 때문에

290
00:16:23,630 --> 00:16:29,640
w(u, v)가 직접 하나의 간선만을
타고 가는 방법이기 때문에

291
00:16:29,640 --> 00:16:33,550
최단 경로보다
길 수밖에 없다고 했었습니다

292
00:16:33,550 --> 00:16:36,290
여기 S에서 B로
직접 가는 경로가 3인 것처럼요

293
00:16:36,290 --> 00:16:38,520
여기 S에서 B로
직접 가는 경로가 3인 것처럼요

294
00:16:38,520 --> 00:16:41,210
최단 경로의 길이인 2보다 크죠

295
00:16:41,210 --> 00:16:42,770
최단 경로의 길이인 2보다 크죠

296
00:16:42,770 --> 00:16:45,710
최단 경로보다 절대 짧을 수 없습니다

297
00:16:45,710 --> 00:16:51,250
그래서 이를 이용하면

298
00:16:51,250 --> 00:16:55,010
δ(s, v)가 d[u] + d[v]보다
작거나 같은 것을 알기 때문에

299
00:16:55,010 --> 00:16:57,530
이가 의미하는 것은

300
00:16:57,530 --> 00:17:00,040
완화 과정을 마치고 나면

301
00:17:00,040 --> 00:17:07,630
이것이 d[v]와 같다는 것입니다

302
00:17:07,630 --> 00:17:09,440
이렇게 동작하게 되는 것입니다

303
00:17:09,440 --> 00:17:11,150
완화 알고리즘이 안전하다는 것을
보였으므로 안심이네요

304
00:17:11,150 --> 00:17:15,276
완화 알고리즘이 안전하다는 것을
보였으므로 안심이네요

305
00:17:15,276 --> 00:17:16,650
저희가 볼 임의의 알고리즘에 대해
적용할 수 있겠죠

306
00:17:16,650 --> 00:17:21,520
저희가 볼 임의의 알고리즘에 대해
적용할 수 있겠죠

307
00:17:21,520 --> 00:17:23,980
최소한 6.006의 최단 경로 수업에서

308
00:17:23,980 --> 00:17:27,560
완화 과정을 여러 번 시행할 때 말이죠

309
00:17:27,560 --> 00:17:31,516
그리고 특수한 경우의 문제를 다룰 때

310
00:17:31,516 --> 00:17:33,640
이 내용을 다른 방법으로 적용하여

311
00:17:33,640 --> 00:17:36,310
최적의 알고리즘을 얻을 것입니다

312
00:17:36,310 --> 00:17:37,200
최적의 알고리즘을 얻을 것입니다

313
00:17:37,200 --> 00:17:40,890
이제 알고리즘을 배우겠습니다

314
00:17:40,890 --> 00:17:43,715
그전에 먼저 DAG를 살펴보겠습니다

315
00:17:53,670 --> 00:17:58,390
DAG는 비순환 방향 그래프의 약자입니다

316
00:17:58,390 --> 00:18:08,430
비순환은 순환이 없다는 의미이므로

317
00:18:08,430 --> 00:18:10,310
음의 순환을 가질 수 없습니다

318
00:18:10,310 --> 00:18:13,410
이것이 저희가 이 특수한 경우에
관심 있는 이유입니다

319
00:18:13,410 --> 00:18:15,470
이것이 문제를 더 쉽게 만들어주는데

320
00:18:15,470 --> 00:18:18,390
음의 순환에 대해
고민할 필요가 없기 때문입니다

321
00:18:18,390 --> 00:18:20,280
저희가 살펴볼 DAG는

322
00:18:20,280 --> 00:18:22,275
음의 간선을 가질 것입니다

323
00:18:22,275 --> 00:18:22,820
음의 간선을 가질 것입니다

324
00:18:22,820 --> 00:18:26,090
DAG에 음의 간선이 있더라도

325
00:18:26,090 --> 00:18:27,730
음의 순환은 없게 되는 것입니다

326
00:18:27,730 --> 00:18:29,284
지난 시간에 말했던 것처럼

327
00:18:29,284 --> 00:18:30,950
음의 간선이 문제를
일으키는 것이 아닙니다

328
00:18:30,950 --> 00:18:34,266
그 간선을 한 번만 지나게 된다면

329
00:18:34,266 --> 00:18:35,640
그 값을 빼주기만 하면

330
00:18:35,640 --> 00:18:36,910
아무런 상관이 없는데

331
00:18:36,910 --> 00:18:38,960
음의 순환을 지나가는 상황이라면

332
00:18:38,960 --> 00:18:41,370
음의 순환을 지나가는 상황이라면

333
00:18:41,370 --> 00:18:42,360
음의 순환을 지나가는 상황이라면

334
00:18:42,360 --> 00:18:45,960
음의 무한대까지
계속 돌 수 있게 됩니다

335
00:18:45,960 --> 00:18:49,840
그러면 최단 경로의 값을
정할 수 없게 됩니다

336
00:18:49,840 --> 00:18:54,320
그래서 이를 어떻게 하냐면

337
00:18:54,320 --> 00:18:56,820
그나저나 연습 문제 같은 데서
DAG를 마주치게 된다면

338
00:18:56,820 --> 00:18:58,820
그나저나 연습 문제 같은 데서
DAG를 마주치게 된다면

339
00:18:58,820 --> 00:19:01,840
가장 먼저 위상 정렬을 해보세요

340
00:19:01,840 --> 00:19:02,430
아시겠죠?

341
00:19:02,430 --> 00:19:05,550
DAG를 다루는 아주 좋은 도구입니다

342
00:19:05,550 --> 00:19:11,690
여기서도 예외는 아니에요

343
00:19:11,690 --> 00:19:13,500
최단 경로를 구하기 위해서

344
00:19:13,500 --> 00:19:17,760
먼저 DAG를 위상 정렬할 것입니다

345
00:19:17,760 --> 00:19:32,770
u에서 v까지의 경로라는 것은

346
00:19:32,770 --> 00:19:41,700
u가 v 이전에 온다는 것을 의미합니다

347
00:19:41,700 --> 00:19:43,692
이 작업을 하게 되면 선형이 됩니다

348
00:19:43,692 --> 00:19:44,900
나중에 예제를 보여드리겠습니다

349
00:19:44,900 --> 00:19:46,510
선형 순서를 갖게 됩니다

350
00:19:46,510 --> 00:19:49,080
그러면 이를 순서대로

351
00:19:49,080 --> 00:19:51,162
왼쪽에서 오른쪽으로 가면서
해당하는 간선에 대해 완화합니다

352
00:19:51,162 --> 00:19:52,620
그렇게 모든 정점에 대해
최단 경로를 구할 수 있게 됩니다

353
00:19:52,620 --> 00:19:55,240
그렇게 모든 정점에 대해
최단 경로를 구할 수 있게 됩니다

354
00:19:55,240 --> 00:20:01,080
그래서 두 번째로 할 일은
왼쪽에서 오른쪽으로 한 번

355
00:20:01,080 --> 00:20:16,980
위상 정렬이 된 순서로 정점을
훑어주는 것입니다

356
00:20:17,000 --> 00:20:20,570
그리고 각 정점에서 나가는
간선에 대하여 완화할 것입니다

357
00:20:20,570 --> 00:20:22,124
그리고 각 정점에서 나가는
간선에 대하여 완화할 것입니다

358
00:20:22,124 --> 00:20:26,020
그리고 각 정점에서 나가는
간선에 대하여 완화할 것입니다

359
00:20:32,940 --> 00:20:36,990
깊이 우선 탐색을 포함하는 위상 정렬은
O(V + E) 복잡도를 갖습니다

360
00:20:36,990 --> 00:20:38,660
깊이 우선 탐색을 포함하는 위상 정렬은
O(V + E) 복잡도를 갖습니다

361
00:20:38,660 --> 00:20:41,460
이 각 정점을 훑는 작업에서
각 정점에 대해 연산을 하고

362
00:20:41,460 --> 00:20:44,490
각 간선에 대해서도 일정한
횟수만큼 하게 됩니다

363
00:20:44,490 --> 00:20:45,970
이 경우는 한 번이 되겠죠

364
00:20:45,970 --> 00:20:53,180
이것이 저희의
첫 최단 경로 알고리즘입니다

365
00:20:53,180 --> 00:20:55,920
그리고 이것은 O(V + E)의
시간 복잡도를 갖습니다

366
00:20:55,920 --> 00:20:57,010
알겠죠?

367
00:20:57,010 --> 00:20:58,570
왜 작동할까요?

368
00:20:58,570 --> 00:21:06,150
한 가지 DAG에 대한 흥미로운 점과

369
00:21:06,150 --> 00:21:09,570
한 가지 DAG에 대한 흥미로운 점과

370
00:21:09,570 --> 00:21:14,810
DAG와 시작 정점의 관계에 대하여

371
00:21:14,810 --> 00:21:17,230
보도록 하겠습니다

372
00:21:17,230 --> 00:21:20,500
예를 하나 보겠습니다

373
00:21:20,500 --> 00:21:23,570
이와 같은 DAG가 있다고 해봅시다

374
00:21:23,570 --> 00:21:26,720
그리고 이 정점을 S라고 합시다

375
00:21:26,720 --> 00:21:30,020
S에서부터 다른 정점 A, B까지의
최단 경로를 찾는다고 해봅시다

376
00:21:30,020 --> 00:21:33,330
S에서부터 다른 정점 A, B까지의
최단 경로를 찾는다고 해봅시다

377
00:21:33,330 --> 00:21:36,280
존재하지 않겠죠?

378
00:21:36,280 --> 00:21:40,170
그래서 이 경우에서는 A까지의
최단 경로가 무한대가 될 것이고

379
00:21:40,170 --> 00:21:42,410
마찬가지로 B까지도
무한대의 거리가 될 것입니다

380
00:21:42,410 --> 00:21:43,710
마찬가지로 B까지도
무한대의 거리가 될 것입니다

381
00:21:43,710 --> 00:21:46,080
아주 자명한 예이지요

382
00:21:46,080 --> 00:21:48,330
이 알고리즘은 일반적입니다

383
00:21:48,330 --> 00:21:51,730
출발할 정점에 대해서는
이야기하고 있지 않습니다

384
00:21:51,730 --> 00:21:52,230
출발할 정점에 대해서는
이야기하고 있지 않습니다

385
00:21:52,230 --> 00:21:55,300
어떠한 출발점을 잡아도
동작하여야 합니다

386
00:21:55,300 --> 00:22:00,530
좋은 점은 위상 정렬을 하고 난 뒤에

387
00:22:00,530 --> 00:22:05,460
그를 보고 어떤 정점에서
시작할지를 정할 수 있다는 것입니다

388
00:22:05,460 --> 00:22:08,890
특정 정점을 하나 정해서
출발점으로 잡고

389
00:22:08,890 --> 00:22:11,600
그곳에서부터 다른 정점까지의

390
00:22:11,600 --> 00:22:15,340
최단 경로를 계산하면 됩니다

391
00:22:15,340 --> 00:22:16,050
최단 경로를 계산하면 됩니다

392
00:22:16,050 --> 00:22:19,640
이렇게 생긴 DAG가 있다고 해봅시다

393
00:22:19,640 --> 00:22:21,640
위상 정렬을 한 뒤에요

394
00:22:21,640 --> 00:22:27,087
DAG는 항상 선형으로
그려질 수 있습니다

395
00:22:27,087 --> 00:22:29,560
좋은 점이죠

396
00:22:37,912 --> 00:22:41,470
가중치는 잠시 후에
적도록 하겠습니다

397
00:22:48,150 --> 00:22:48,650
이 DAG입니다

398
00:22:48,650 --> 00:22:52,870
이 DAG입니다

399
00:22:52,880 --> 00:22:53,380
5, 3, 2, 6, 7, 4, 2, -1, -2

400
00:22:53,380 --> 00:23:04,160
5, 3, 2, 6, 7, 4, 2, -1, -2

401
00:23:07,970 --> 00:23:09,240
그래서 이 DAG입니다

402
00:23:09,240 --> 00:23:12,840
위상 정렬된 형태로 그렸습니다

403
00:23:12,840 --> 00:23:14,300
왼쪽으로 오른쪽으로 향하도록요

404
00:23:14,300 --> 00:23:19,080
이제 2단계를 하면 됩니다

405
00:23:19,080 --> 00:23:20,810
최단 경로를 찾겠습니다

406
00:23:20,810 --> 00:23:23,490
출발점을 정할 필요가 있습니다

407
00:23:23,490 --> 00:23:28,850
이 정점을 출발점으로 정하게 된다면

408
00:23:28,850 --> 00:23:31,160
할 수 있는 것이 아무것도 없습니다

409
00:23:31,160 --> 00:23:33,440
나가는 간선이 없기 때문이죠

410
00:23:33,440 --> 00:23:36,510
이로부터 왼쪽에 있는 모든 정점까지의
거리는 무한대가 됩니다

411
00:23:36,510 --> 00:23:37,930
이로부터 왼쪽에 있는 모든 정점까지의
거리는 무한대가 됩니다

412
00:23:37,930 --> 00:23:38,740
이로부터 왼쪽에 있는 모든 정점까지의
거리는 무한대가 됩니다

413
00:23:38,740 --> 00:23:40,590
그래서 가장 먼저 해야 할 것은

414
00:23:40,590 --> 00:23:44,180
출발할 정점을 정하는 것입니다

415
00:23:44,180 --> 00:23:46,790
출발할 정점을 정하는 것입니다

416
00:23:46,790 --> 00:23:50,210
이 정점을 출발점으로
잡아보도록 하겠습니다

417
00:23:50,210 --> 00:23:53,900
두껍게 그리도록 하겠습니다

418
00:23:53,900 --> 00:23:55,120
이 정점이 출발점입니다

419
00:23:55,120 --> 00:23:57,060
자명하지 않은 경우를 선택했습니다

420
00:23:57,060 --> 00:23:59,570
이로부터 왼쪽에 있는 모든 정점에

421
00:23:59,570 --> 00:24:02,980
무한대라고 적어놓겠습니다

422
00:24:02,980 --> 00:24:07,020
이제 완화 작업을 하도록 하겠습니다

423
00:24:07,020 --> 00:24:10,080
한 번의 단계로
바로 특정한 정점까지의

424
00:24:10,080 --> 00:24:14,530
최단 경로를 얻을 수는
없을 것입니다

425
00:24:14,530 --> 00:24:16,250
왜냐하면 더 나은 길이
있을 수도 있기 때문입니다

426
00:24:16,250 --> 00:24:18,350
특별히 음의 간선이 있을 때
더 그럴 것입니다

427
00:24:18,350 --> 00:24:21,970
더 많은 정점을 거쳐 가는 길이

428
00:24:21,970 --> 00:24:24,230
최단 경로일 수도 있기 때문입니다

429
00:24:24,230 --> 00:24:27,020
하지만 일단 S를 보고

430
00:24:27,020 --> 00:24:30,610
S에서 뻗어 나가는 간선에 대해
완화하도록 하겠습니다

431
00:24:30,610 --> 00:24:32,520
처음으로 모든 정점을

432
00:24:32,520 --> 00:24:34,350
무한대로 초기화합니다

433
00:24:34,350 --> 00:24:35,910
모든 것은 무한대입니다

434
00:24:35,910 --> 00:24:37,780
이로부터 왼쪽에 있는 것은
무한대로 유지됩니다

435
00:24:37,780 --> 00:24:40,500
오른쪽에 있는 정점들은
갈 수 있을 것입니다

436
00:24:40,500 --> 00:24:47,110
이 값들은 갱신이 되겠죠

437
00:24:47,110 --> 00:24:51,230
이렇게 가면 여기는 2가 됩니다

438
00:24:51,230 --> 00:24:52,970
여기는 6이 되고요

439
00:24:52,970 --> 00:24:54,350
이 길을 따라간다면요

440
00:24:54,350 --> 00:24:58,940
이러면 S에 대해서는
완료했습니다

441
00:24:58,940 --> 00:25:00,160
이렇게 되겠죠

442
00:25:00,160 --> 00:25:01,310
2와 6이요

443
00:25:01,310 --> 00:25:04,560
다음으로는 이 정점에 대하여
진행합니다

444
00:25:04,560 --> 00:25:06,770
이 정점을 A라고 부르겠습니다

445
00:25:06,770 --> 00:25:09,900
A로부터 나가는 간선에 대해
완화하겠습니다

446
00:25:09,900 --> 00:25:14,560
A로부터 나오면 2 + 7이

447
00:25:14,560 --> 00:25:17,010
9가 되므로 6보다 크게 됩니다

448
00:25:17,010 --> 00:25:19,260
그러면 이 값은
갱신할 필요가 없겠죠

449
00:25:19,260 --> 00:25:22,840
2 + 4는 무한대보다 작습니다

450
00:25:22,840 --> 00:25:26,750
그래서 여기는 6으로 갱신합니다

451
00:25:26,750 --> 00:25:31,140
2 + 2로 여기는 4가 되고요

452
00:25:31,140 --> 00:25:32,740
이런 식으로 진행합니다

453
00:25:32,740 --> 00:25:34,710
이러면 A에 대해서도 끝나게 됩니다

454
00:25:34,710 --> 00:25:39,020
이 정점을 B라고 하고
6의 값을 가지고 있으므로

455
00:25:39,020 --> 00:25:42,255
6 - 1은 6보다 작기 때문에

456
00:25:42,255 --> 00:25:44,810
여기는 5가 됩니다

457
00:25:44,810 --> 00:25:49,930
5 - 2는
아 여기는 다음 단계이군요

458
00:25:49,930 --> 00:25:52,630
여기를 빼먹었군요 1입니다

459
00:25:52,630 --> 00:25:55,717
6 + 1은 7입니다

460
00:25:55,717 --> 00:25:56,800
하지만 4보다 크기 때문에

461
00:25:56,800 --> 00:25:58,870
여기는 아무것도 하지 않습니다

462
00:25:58,870 --> 00:26:05,410
이런 식으로 하면 최종적으로
여기는 3이 됩니다

463
00:26:05,410 --> 00:26:07,230
최종값입니다

464
00:26:07,230 --> 00:26:09,840
여기는 최종적으로 5가 되고요

465
00:26:09,840 --> 00:26:12,090
여기는 6이

466
00:26:12,090 --> 00:26:14,020
여기는 2

467
00:26:14,020 --> 00:26:15,650
여기는 0이 됩니다

468
00:26:15,650 --> 00:26:17,460
그리고 여기는 무한대로 남아있습니다

469
00:26:17,460 --> 00:26:18,470
알겠죠?

470
00:26:18,470 --> 00:26:20,680
꽤 간단합니다

471
00:26:20,680 --> 00:26:22,560
위상 정렬을 하고

472
00:26:22,560 --> 00:26:24,180
출발점을 찾습니다

473
00:26:24,180 --> 00:26:27,130
그리고 가장 오른쪽까지
진행하면 됩니다

474
00:26:27,130 --> 00:26:30,580
흥미롭게도 이는 동적 계획법의
아주 간단한 예입니다

475
00:26:30,580 --> 00:26:33,150
동적 계획법은 나중에 11월쯤
자세히 배우게 될 것입니다

476
00:26:33,150 --> 00:26:36,460
동적 계획법은 나중에 11월쯤
자세히 배우게 될 것입니다

477
00:26:36,460 --> 00:26:44,250
여기서 한 것은 아주 간단한
특수한 그래프에서의

478
00:26:44,250 --> 00:26:48,160
O(V + E)의 복잡도를 갖는

479
00:26:48,160 --> 00:26:49,430
최단 경로 알고리즘이었습니다

480
00:26:49,430 --> 00:26:52,120
이가 가능한 이유는
순환이 없기 때문입니다

481
00:26:52,120 --> 00:26:53,150
아시겠죠?

482
00:26:53,150 --> 00:26:55,220
질문 있나요?

483
00:26:55,220 --> 00:26:57,630
모두 이해하셨죠?

484
00:26:57,630 --> 00:26:58,450
잘 되나요?

485
00:26:58,450 --> 00:26:59,370
알겠습니다

486
00:26:59,370 --> 00:27:02,260
이로써 하나의 알고리즘을 배웠습니다

487
00:27:02,260 --> 00:27:05,080
이제부터는 더 흥미로운 경우에 대해
살펴볼 것입니다

488
00:27:05,080 --> 00:27:08,380
그래프 대부분은
순환이 있기 때문이죠

489
00:27:08,380 --> 00:27:12,090
하지만 일단 음의 간선이 없는
특수한 경우에 대해서만 살펴보겠습니다

490
00:27:12,090 --> 00:27:13,340
하지만 일단 음의 간선이 없는
특수한 경우에 대해서만 살펴보겠습니다

491
00:27:13,340 --> 00:27:13,840
하지만 일단 음의 간선이 없는
특수한 경우에 대해서만 살펴보겠습니다

492
00:27:13,840 --> 00:27:18,720
다익스트라 알고리즘은
음의 간선에 대해 동작하지 않습니다

493
00:27:18,720 --> 00:27:20,070
이와는 완전히 다릅니다

494
00:27:20,070 --> 00:27:23,150
다익스트라 알고리즘은
이 경우를 포함하지 않습니다

495
00:27:23,150 --> 00:27:25,100
그 점이 중요합니다

496
00:27:25,100 --> 00:27:28,340
다익스트라 알고리즘은
순환이 있는 그래프에선 동작하지만

497
00:27:28,340 --> 00:27:32,740
모든 간선의 가중치는
0이거나 양수이어야 합니다

498
00:27:32,740 --> 00:27:35,740
이 알고리즘은 DAG에서 작동하고
음의 간선이 있어도 됩니다

499
00:27:35,740 --> 00:27:37,340
하지만 순환이 있어서는 안 됩니다

500
00:27:37,340 --> 00:27:41,010
그래서 각각의 알고리즘은
각각 알맞은 용도가 있습니다

501
00:27:43,330 --> 00:27:46,230
이제 다익스트라 알고리즘을
살펴보겠습니다

502
00:27:46,230 --> 00:27:48,010
직접 예시로 보여드리도록 하겠습니다

503
00:27:48,010 --> 00:27:57,390
6.006에서 하는 예시입니다

504
00:27:57,390 --> 00:28:00,460
다익스트라는 상당히
직관적인 알고리즘입니다

505
00:28:00,460 --> 00:28:04,590
타당성을 증명하는 것은
자명하지 않습니다만

506
00:28:04,590 --> 00:28:09,170
구현하고 그 흐름을
이해하는 관점에서는

507
00:28:09,170 --> 00:28:10,640
상당히 직관적이라고 할 수 있겠습니다

508
00:28:10,640 --> 00:28:12,020
상당히 직관적이라고 할 수 있겠습니다

509
00:28:12,020 --> 00:28:14,060
그렇게 되는 이유 중 하나는

510
00:28:14,060 --> 00:28:17,260
이것이 탐욕 알고리즘이기 때문입니다

511
00:28:17,260 --> 00:28:21,710
점차 이익을 극대화하면서

512
00:28:21,710 --> 00:28:22,780
점차 이익을 극대화하면서

513
00:28:22,780 --> 00:28:26,000
반복적으로 최단 경로를 만듭니다

514
00:28:26,000 --> 00:28:28,770
정점에서 정점으로 진행하면서요

515
00:28:28,770 --> 00:28:31,410
다익스트라를 직접
보여드리겠습니다

516
00:28:31,410 --> 00:28:33,419
왜 직접 보여드리냐면

517
00:28:33,419 --> 00:28:35,960
이를 보면 왜 다익스트라가 작동하는지
직관적으로 알 수 있을 것이기 때문입니다

518
00:28:35,960 --> 00:28:36,753
이를 보면 왜 다익스트라가 작동하는지
직관적으로 알 수 있을 것이기 때문입니다

519
00:28:36,753 --> 00:28:41,040
한 가지 얘기해드리자면

520
00:28:41,040 --> 00:28:43,070
이보다 더 기울이게 되면

521
00:28:43,070 --> 00:28:45,150
공이 떨어져서 더 못 기울입니다

522
00:28:45,150 --> 00:28:49,180
카메라에 잘 담기나요?

523
00:28:49,180 --> 00:28:49,680
네

524
00:28:49,680 --> 00:28:52,270
기록에 남겨야죠

525
00:28:52,270 --> 00:28:55,440
무방향 그래프가 있습니다

526
00:28:55,440 --> 00:28:58,480
위에 이것들은 정점입니다

527
00:28:58,480 --> 00:29:01,200
공들이 정점을 나타내고

528
00:29:01,200 --> 00:29:03,010
그 위에 그림을 그렸습니다

529
00:29:03,010 --> 00:29:04,280
G는 초록색을 의미하고

530
00:29:04,280 --> 00:29:06,350
Y는 노란색을 의미하는 식입니다

531
00:29:06,350 --> 00:29:09,080
저 칠판에 있는 것이 이 그래프입니다

532
00:29:09,080 --> 00:29:16,540
이 공들을 연결한 실의 길이는

533
00:29:16,540 --> 00:29:21,970
저 칠판에 있는 가중치를 의미합니다

534
00:29:21,970 --> 00:29:25,700
그래서 제대로 만들었다면

535
00:29:25,700 --> 00:29:30,190
위에 있는 초록 공과 노란 공을 연결하는 실은

536
00:29:30,190 --> 00:29:31,860
19센티미터 일 것입니다

537
00:29:31,860 --> 00:29:33,935
다른 것도 그렇게 되어있습니다

538
00:29:33,935 --> 00:29:35,250
아시겠죠?

539
00:29:35,250 --> 00:29:37,800
그래서 저게 다익스트라고

540
00:29:37,800 --> 00:29:41,610
그래서 제가 최단 경로를
계산하기 위해서

541
00:29:41,610 --> 00:29:46,209
물리적으로 어떤 일을 해야 할까요?

542
00:29:46,209 --> 00:29:50,270
어떠한 작업을 해야 할까요?

543
00:29:50,270 --> 00:29:53,720
말해보실 분

544
00:29:53,741 --> 00:29:55,532
학생: 공을 들어 올려서 그냥…

545
00:29:55,532 --> 00:29:56,630
공을 들어 올린다

546
00:29:56,630 --> 00:29:57,171
네 맞습니다

547
00:29:57,171 --> 00:29:58,020
잘하셨어요

548
00:29:58,020 --> 00:30:00,250
방석 받으세요

549
00:30:00,250 --> 00:30:05,740
직접 해보도록 하겠습니다

550
00:30:05,740 --> 00:30:10,720
저기 쓰여있는 값들은 이해하시겠나요

551
00:30:10,720 --> 00:30:15,730
초록색 공이 출발점이라면

552
00:30:15,730 --> 00:30:21,790
보라색 정점 P까지의
최단 거리는 7이라는 것입니다

553
00:30:21,790 --> 00:30:24,530
그게 G로부터 가장 가까운 정점이고요

554
00:30:24,530 --> 00:30:27,360
다음으로 가까운 정점은

555
00:30:27,360 --> 00:30:30,540
파란색 정점 B로
12의 거리에 있네요

556
00:30:30,540 --> 00:30:31,830
7 + 5

557
00:30:31,830 --> 00:30:33,210
이런 식으로 되어 있습니다

558
00:30:33,210 --> 00:30:35,890
이게 잘 된다면
아직 해보지는 않았습니다만

559
00:30:35,890 --> 00:30:37,930
이게 한 번밖에 쓸 수가 없어서
해볼 수가 없었습니다

560
00:30:37,930 --> 00:30:41,780
이것을 들어 올렸을 때
실들이 너무 엉켜

561
00:30:41,780 --> 00:30:42,860
더는 사용할 수 없게 되더라고요

562
00:30:42,860 --> 00:30:43,440
더는 사용할 수 없게 되더라고요

563
00:30:43,440 --> 00:30:46,090
그래서 이걸 다시 다 풀어서
원위치할 수 밖에 없었습니다

564
00:30:46,090 --> 00:30:47,780
이건 컴퓨터처럼
되돌릴 수 있는 게 아닙니다

565
00:30:47,780 --> 00:30:49,335
이건 컴퓨터처럼
되돌릴 수 있는 게 아닙니다

566
00:30:49,335 --> 00:30:51,340
다익스트라를 짜는 것이 낫겠군요

567
00:30:51,340 --> 00:30:54,670
그래서 이걸 그냥
들어 올려서 이렇게 하면

568
00:30:54,670 --> 00:30:56,337
그리고 원위치로 돌려주면

569
00:30:56,337 --> 00:30:56,836
네 이렇게 되어야죠

570
00:30:56,836 --> 00:30:57,520
네 이렇게 되어야죠

571
00:30:57,520 --> 00:30:59,720
제대로 맞추려고
조작하는 것 같지만요

572
00:30:59,720 --> 00:31:01,530
제대로 맞추려고
조작하는 것 같지만요

573
00:31:01,530 --> 00:31:03,115
가장 위에 초록색이
있는걸 볼 수 있고요

574
00:31:03,115 --> 00:31:04,490
다음에는 무슨 색이 오나요?

575
00:31:04,490 --> 00:31:05,010
보라색

576
00:31:05,010 --> 00:31:05,450
보라색

577
00:31:05,450 --> 00:31:05,969
좋습니다

578
00:31:05,969 --> 00:31:07,135
그다음에는 무엇이 오나요?

579
00:31:07,135 --> 00:31:07,450
파란색

580
00:31:07,450 --> 00:31:08,116
파란색

581
00:31:08,116 --> 00:31:10,220
맞아요

582
00:31:10,220 --> 00:31:11,950
Y 다음 R이 옵니다

583
00:31:11,950 --> 00:31:18,310
장력이 걸려 팽팽한 실들이 있는데
선행 정점들을 이야기합니다

584
00:31:18,310 --> 00:31:19,880
이것이 ∏입니다

585
00:31:19,880 --> 00:31:20,440
이것이 ∏입니다

586
00:31:20,440 --> 00:31:23,350
최단 경로를 계산해냈습니다

587
00:31:23,350 --> 00:31:24,340
물리적으로요

588
00:31:24,340 --> 00:31:27,660
실의 장력을 측정하는 방법이 있다면

589
00:31:27,660 --> 00:31:30,921
선행 관계 ∏도 알아낼 수 있겠죠

590
00:31:30,921 --> 00:31:31,420
선행 관계 ∏도 알아낼 수 있겠죠

591
00:31:31,420 --> 00:31:32,060
선행 관계 ∏도 알아낼 수 있겠죠

592
00:31:32,060 --> 00:31:33,972
제대로 동작하는지 봅시다

593
00:31:33,972 --> 00:31:35,090
제대로 동작하죠?

594
00:31:35,090 --> 00:31:40,270
두 번째 경우가 제대로 안 되더라도
제게 비판하지 마세요

595
00:31:40,270 --> 00:31:44,950
R을 잡고 올려봅시다

596
00:31:44,950 --> 00:31:46,810
아이코

597
00:31:46,810 --> 00:31:50,430
그래서 R 뒤에
Y, B, P, G 순으로 옵니다

598
00:31:50,430 --> 00:31:51,490
그래서 R 뒤에
Y, B, P, G 순으로 옵니다

599
00:31:51,490 --> 00:31:52,820
여러분

600
00:31:52,820 --> 00:31:54,560
박수 주세요

601
00:31:54,560 --> 00:31:55,170
알겠죠?

602
00:31:55,170 --> 00:31:55,670
잘 되네요

603
00:31:55,670 --> 00:31:56,180
감사합니다

604
00:31:56,180 --> 00:31:57,422
감사합니다

605
00:31:57,422 --> 00:31:59,290
감사합니다

606
00:31:59,290 --> 00:32:06,750
제가 이 시연을 한 데에는
이유가 있습니다

607
00:32:06,750 --> 00:32:09,600
탐욕 알고리즘이 있었죠

608
00:32:09,600 --> 00:32:11,390
여기서 탐욕은 중력이었다고 생각합니다

609
00:32:11,390 --> 00:32:11,890
여기서 탐욕은 중력이었다고 생각합니다

610
00:32:11,890 --> 00:32:13,830
중력은 탐욕스럽죠

611
00:32:13,830 --> 00:32:16,904
당연하게도 공이 매달려 있는 이유는

612
00:32:16,904 --> 00:32:18,070
공이 무게를 가지고 있고

613
00:32:18,070 --> 00:32:19,140
중력이 있기 때문입니다

614
00:32:19,140 --> 00:32:21,812
그럼 이제 물리를 하는 사람들은
상상하실 수 있을 겁니다

615
00:32:21,812 --> 00:32:23,520
물리 전공하시는 분이 있는지
잘 모르겠네요

616
00:32:23,520 --> 00:32:26,300
물리를 복수 전공하시는 분 있나요?

617
00:32:26,300 --> 00:32:27,980
네 계시네요

618
00:32:27,980 --> 00:32:30,000
뉴턴 운동 법칙을 알고 계시고

619
00:32:30,000 --> 00:32:31,900
중력에 대해서 알고 계시겠네요

620
00:32:31,900 --> 00:32:33,780
그럼 이런 것들을 상상하실 수 있겠죠

621
00:32:33,780 --> 00:32:36,775
연습 문제의 우선순위 큐랑은
무슨 관계일지

622
00:32:36,775 --> 00:32:38,150
앞으로 이야기할 알고리즘인

623
00:32:38,150 --> 00:32:39,660
다익스트라와는 무슨 관계일지요

624
00:32:39,660 --> 00:32:43,770
실제 최단 경로 값들을 구해내기 위해

625
00:32:43,770 --> 00:32:47,790
물리적인 시뮬레이션을 한다고 하면

626
00:32:47,790 --> 00:32:48,290
물리적인 시뮬레이션을 한다고 하면

627
00:32:48,290 --> 00:32:49,790
멋지긴 할 테지만

628
00:32:49,790 --> 00:32:51,730
끔찍하게 느릴 것입니다

629
00:32:51,730 --> 00:32:54,660
앞으로 이야기할
다익스트라 알고리즘은

630
00:32:54,660 --> 00:32:57,980
안정된 상태를 계산할 뿐입니다

631
00:32:57,980 --> 00:33:04,810
그 상태가 G와 가까운 정도에
대응되게 됩니다

632
00:33:04,810 --> 00:33:07,670
다익스트라 알고리즘 뒤에
숨겨진 발상은

633
00:33:07,670 --> 00:33:10,710
탐욕적으로 최단 경로를
만들어내겠다는 것입니다

634
00:33:10,710 --> 00:33:12,650
시작은 출발점인 G에서 시작하고요

635
00:33:12,650 --> 00:33:13,982
시작은 출발점인 G에서 시작하고요

636
00:33:13,982 --> 00:33:15,440
가장 먼저 계산하고
찾아낼 최단 경로는

637
00:33:15,440 --> 00:33:17,455
가장 먼저 계산하고
찾아낼 최단 경로는

638
00:33:17,455 --> 00:33:19,220
보라색으로 향하는
경로가 될 것입니다

639
00:33:19,220 --> 00:33:20,070
다음은 파란색

640
00:33:20,070 --> 00:33:21,120
그다음은 노란색

641
00:33:21,120 --> 00:33:21,940
다음은 빨간색 순으로요

642
00:33:21,940 --> 00:33:22,440
다음은 빨간색 순으로요

643
00:33:22,440 --> 00:33:26,530
이 시연의 특정 면을
모방하고 있는 것이죠

644
00:33:26,530 --> 00:33:29,762
이 시연의 특정 면을
모방하고 있는 것이죠

645
00:33:29,762 --> 00:33:31,970
그럼 이제 다익스트라의
의사 코드를 살펴보겠습니다

646
00:34:00,090 --> 00:34:01,290
G는 그래프

647
00:34:01,290 --> 00:34:03,050
W는 가중치

648
00:34:03,050 --> 00:34:06,760
소문자 s는 출발점을 의미합니다

649
00:34:06,760 --> 00:34:14,150
(G, s)를 초기화합니다

650
00:34:14,150 --> 00:34:18,330
여기서 초기화한다는 것은
그냥 s를 시작점으로 표시한다는 뜻입니다

651
00:34:18,330 --> 00:34:22,780
대문자 S도 사용할 것인데

652
00:34:22,780 --> 00:34:27,050
구분하기 위해서 작은 선을 그어
표시하겠습니다

653
00:34:27,050 --> 00:34:28,199
이는 집합입니다

654
00:34:28,199 --> 00:34:30,880
대문자 S는 집합입니다

655
00:34:30,880 --> 00:34:33,590
이를 공집합으로 초기화합니다

656
00:34:33,590 --> 00:34:36,170
Q라는 다른 집합도 있습니다

657
00:34:36,170 --> 00:34:40,400
이는 정점 집합 전체로 초기화됩니다

658
00:34:40,400 --> 00:34:43,110
이가 의미하는 것은 처음에

659
00:34:43,110 --> 00:34:44,420
아무것도 처리하지 않았음을
나타냅니다

660
00:34:44,420 --> 00:34:49,230
그리고 어떠한 정점으로 가는
최단 경로도 모른다는 의미로

661
00:34:49,230 --> 00:34:52,860
이 집합이 공집합이고

662
00:34:52,860 --> 00:34:56,310
Q가 처리해야 할
정점의 집합인 것입니다

663
00:34:56,310 --> 00:34:59,560
Q에 있는 정점을 처리해 가면서

664
00:34:59,560 --> 00:35:01,960
처리된 정점을
S 집합으로 옮길 것입니다

665
00:35:01,960 --> 00:35:04,480
그러면 S는 최단 경로를 아는
정점들의 집합이 될 것입니다

666
00:35:04,480 --> 00:35:08,660
그러면 S는 최단 경로를 아는
정점들의 집합이 될 것입니다

667
00:35:08,660 --> 00:35:10,960
이것이 이 알고리즘의
불변조건이 될 것입니다

668
00:35:10,960 --> 00:35:13,422
S가 저희가 최단 경로를 아는 정점의
집합이라는 사실 말입니다

669
00:35:13,422 --> 00:35:16,190
S가 저희가 최단 경로를 아는 정점의
집합이라는 사실 말입니다

670
00:35:17,440 --> 00:35:22,970
그래서 다익스트라는
while 문으로 되어 있고

671
00:35:22,970 --> 00:35:24,740
처리되어야 할 정점이 남아있을 동안

672
00:35:24,740 --> 00:35:32,300
u를 꺼내는데

673
00:35:32,300 --> 00:35:46,190
EXTRACT-MIN(Q)를 통해
꺼낼 것입니다

674
00:35:46,190 --> 00:35:54,410
이 부분이 Q에서
u를 제거할 것입니다

675
00:35:54,410 --> 00:35:58,430
여기 이 초기화 구문들이
이건 소문자 s입니다

676
00:35:58,430 --> 00:36:05,240
d[s]를 0으로 설정할 것입니다

677
00:36:05,240 --> 00:36:07,170
이것이 이 초기화가 하는 일입니다

678
00:36:07,170 --> 00:36:08,930
처음에 알 수 있는 것이
이것이기 때문이죠

679
00:36:08,930 --> 00:36:10,334
출발점이 있고

680
00:36:10,334 --> 00:36:12,750
출발점에서 출발점까지의
최단 경로의 거리가

681
00:36:12,750 --> 00:36:15,240
0이라는 것을 알고

682
00:36:15,240 --> 00:36:18,150
이래서 이가 의미하는 것은
나머지 정점은

683
00:36:18,150 --> 00:36:19,700
무한대의 값을 갖는다는 것입니다

684
00:36:19,700 --> 00:36:22,060
그래서 맨 첫 단계에서는

685
00:36:22,060 --> 00:36:24,730
EXTRACT-MIN(Q)가

686
00:36:24,730 --> 00:36:27,670
출발점인 S를 꺼낼 것입니다

687
00:36:27,670 --> 00:36:31,660
그리고 그것을 u에 할당합니다

688
00:36:31,660 --> 00:36:35,040
그리고 집합 S를 S ∪ {u}로
다시 할당해줍니다

689
00:36:35,040 --> 00:36:42,520
그리고 집합 S를 S ∪ {u}로
다시 할당해줍니다

690
00:36:42,520 --> 00:36:49,350
그리고 우리가 해야 될 것은
방금 추가한 정점의 간선에 대해

691
00:36:49,350 --> 00:36:50,640
완화하는 것입니다

692
00:36:50,640 --> 00:36:57,910
정점 u와 이웃인
각각의 정점 v에 대하여

693
00:36:57,910 --> 00:37:00,670
다시 말해, u에서 도달할 수 있는
정점에 대하여

694
00:37:00,670 --> 00:37:05,788
(u, v, w)로 완화합니다

695
00:37:08,476 --> 00:37:09,380
네 이것이 다익스트라입니다

696
00:37:09,380 --> 00:37:10,060
네 이것이 다익스트라입니다

697
00:37:10,060 --> 00:37:14,796
네 이것이 다익스트라입니다

698
00:37:14,890 --> 00:37:17,460
탐욕 알고리즘이고

699
00:37:17,460 --> 00:37:18,930
반복적이죠

700
00:37:18,930 --> 00:37:21,690
이것이 탐욕 알고리즘인 이유는
이 단계 때문입니다

701
00:37:21,690 --> 00:37:25,590
우선순위가 가장 낮은 정점을

702
00:37:25,590 --> 00:37:30,760
처리되지 않은 정점들의 집합
Q에서 고르기 때문입니다

703
00:37:30,760 --> 00:37:37,590
그리고 이 낮은 우선순위는
이전에 계산해두었던

704
00:37:37,590 --> 00:37:40,160
최단 경로의 값이라
여기는 것입니다

705
00:37:40,160 --> 00:37:42,800
그래서 S에 정점을 집어넣을 때

706
00:37:42,800 --> 00:37:45,110
이 정점의 계산은 끝났다고
취급하는 것이죠

707
00:37:45,110 --> 00:37:48,220
이 특정 정점까지의
최단 경로를 알고 있고

708
00:37:48,220 --> 00:37:51,580
그리고 그 정점에 대해
처리해주어야 한다는 의미입니다

709
00:37:51,580 --> 00:37:55,250
그 정점에서 나가는 간선에 대해
완화해주어야 한다는 관점에서 말이죠

710
00:37:55,250 --> 00:37:58,610
그리고 우선순위를 갱신해야 할 것입니다

711
00:37:58,610 --> 00:38:02,780
왜냐하면 완화 작업은 이미 알듯이
d 값의 변화를 끌어내기 때문입니다

712
00:38:02,780 --> 00:38:07,280
해당하는 정점 v에 대해서 말이죠
값이 변할 수도 있고

713
00:38:07,280 --> 00:38:08,310
변하지 않을 수도 있습니다

714
00:38:08,310 --> 00:38:10,950
하지만 변할 가능성이 있습니다

715
00:38:10,950 --> 00:38:13,280
이 작업을 정점 u로부터 나가는

716
00:38:13,280 --> 00:38:15,937
모든 간선에 대해 하면 됩니다

717
00:38:15,937 --> 00:38:18,270
그러면 아마도 우선순위의
많은 변화가 뒤따르겠죠

718
00:38:18,270 --> 00:38:18,770
그러면 아마도 우선순위의
많은 변화가 뒤따르겠죠

719
00:38:18,770 --> 00:38:20,940
다음 단계에서는

720
00:38:20,940 --> 00:38:27,270
다른 최소 우선순위를 갖는 정점이
선택될 것입니다

721
00:38:27,270 --> 00:38:27,970
두 가지 이유에서요

722
00:38:27,970 --> 00:38:31,050
첫 번째는 최소 우선순위를 갖는 정점을
추출했기 때문입니다

723
00:38:31,050 --> 00:38:32,530
Q에서 제거했기 때문이죠

724
00:38:32,530 --> 00:38:36,340
두 번째 이유는 반복문을 실행하면서

725
00:38:36,340 --> 00:38:38,200
우선순위를 변경하였기 때문입니다

726
00:38:38,200 --> 00:38:39,110
우선순위를 변경하였기 때문입니다

727
00:38:39,110 --> 00:38:41,960
그래서 조금 전의 시연에서

728
00:38:41,960 --> 00:38:46,120
처음에 초록색 정점을 들어 올린 것은

729
00:38:46,120 --> 00:38:49,220
그 정점을 출발점으로
지정한 것을 의미합니다

730
00:38:49,220 --> 00:38:51,570
실에 의해 매달린 것으로 알 수 있었던

731
00:38:51,570 --> 00:38:55,550
그로부터 가장 가까이 있던 것이

732
00:38:55,550 --> 00:38:57,174
최소 우선순위를 가지는 정점이었습니다

733
00:38:57,174 --> 00:38:58,090
그리고 그것을 꺼냅니다

734
00:38:58,090 --> 00:39:01,420
그렇게 계속해서 아래로 내려갑니다

735
00:39:01,420 --> 00:39:04,445
이것을 따로 보고
증명하지는 않을 것이지만

736
00:39:04,445 --> 00:39:06,570
읽어볼 가치는 있습니다

737
00:39:06,570 --> 00:39:10,610
CLRS에 반 쪽 정도
되는 증명입니다

738
00:39:10,610 --> 00:39:12,480
다익스트라에 대한 증명은 읽어야겠죠

739
00:39:12,480 --> 00:39:13,791
다익스트라에 대한 증명은 읽어야겠죠

740
00:39:13,791 --> 00:39:15,790
그냥 근본적으로 경우를 세고

741
00:39:15,790 --> 00:39:16,940
그냥 근본적으로 경우를 세고

742
00:39:16,940 --> 00:39:20,290
저희가 증명했던 완화 연산이 안전하다는

743
00:39:20,290 --> 00:39:24,540
보조 정리를 이용합니다

744
00:39:24,540 --> 00:39:25,370
보조 정리를 이용합니다

745
00:39:25,370 --> 00:39:26,770
다익스트라에 관련해서 질문 있나요?

746
00:39:26,770 --> 00:39:29,141
아니면 의사 코드나
다른 질문들 있나요?

747
00:39:29,141 --> 00:39:31,390
언젠가는 구현하게 될 것입니다

748
00:39:31,390 --> 00:39:31,600
네

749
00:39:31,600 --> 00:39:33,350
학생: 어떻게 정점들을 비교하나요?

750
00:39:33,350 --> 00:39:34,250
학생: 어떻게 정점들을 비교하나요?

751
00:39:34,250 --> 00:39:36,015
좋은 질문입니다

752
00:39:36,015 --> 00:39:38,795
명확하게 할 필요가 있었습니다

753
00:39:40,810 --> 00:39:43,420
Q는 우선순위 큐입니다

754
00:39:43,420 --> 00:39:48,800
그리고 여기서 우선순위는
각 정점의 d 값입니다

755
00:39:52,890 --> 00:39:55,900
처음에 S가 공집합이 되는 것은
이해하시리라 믿습니다

756
00:39:55,900 --> 00:39:56,920
이건 명확하고

757
00:39:56,920 --> 00:39:59,580
Q가 정점의 집합이 되는 것도
이해하시죠

758
00:39:59,580 --> 00:40:03,030
Q는 우선순위 큐입니다

759
00:40:03,030 --> 00:40:06,530
그리고 이 우선순위 큐를
어떻게 구현하는지와

760
00:40:06,530 --> 00:40:08,570
다익스트라의 복잡도에 대한 이야기는

761
00:40:08,570 --> 00:40:09,840
수업이 끝나기 전에 할 것입니다

762
00:40:09,840 --> 00:40:12,440
추상 자료형으로 본다면

763
00:40:12,440 --> 00:40:14,230
Q를 우선순위 큐라고 보면 됩니다

764
00:40:14,230 --> 00:40:17,190
그리고 Q 안에 있는 각 정점에
우선순위가 부여되어 있고

765
00:40:17,190 --> 00:40:19,650
이 우선순위는 변하고 값은 d입니다

766
00:40:19,650 --> 00:40:21,211
이 우선순위는 변하고 값은 d입니다

767
00:40:21,211 --> 00:40:21,710
이 우선순위는 변하고 값은 d입니다

768
00:40:21,710 --> 00:40:22,460
이 우선순위는 변하고 값은 d입니다

769
00:40:30,720 --> 00:40:34,860
그래서 처음에는 d[s]가 0이고

770
00:40:34,860 --> 00:40:37,280
나머지는 무한대입니다

771
00:40:37,280 --> 00:40:39,350
그래서 가장 처음에

772
00:40:39,350 --> 00:40:42,590
u가 출발점 s가 된다는 것은
확실합니다

773
00:40:42,590 --> 00:40:44,980
그러면 s에서 나가는 간선에 대해 완화하게 되는데

774
00:40:44,980 --> 00:40:47,890
이로써 다른 무한대 값을
변경할 수 있을 것입니다

775
00:40:47,890 --> 00:40:49,530
s에서 무한대보다 작은 거리로
도달할 수 있는 정점에 대해서요

776
00:40:49,530 --> 00:40:51,850
s에서 무한대보다 작은 거리로
도달할 수 있는 정점에 대해서요

777
00:40:51,850 --> 00:40:55,420
본질적으로는

778
00:40:55,420 --> 00:40:58,580
이 우선순위 큐에서
값을 변경하는 것이죠

779
00:40:58,580 --> 00:40:59,187
그리고 다시 반복해

780
00:40:59,187 --> 00:41:01,280
다음번에 최소 우선순위를
선택하는 식으로 진행됩니다

781
00:41:01,280 --> 00:41:02,300
다음번에 최소 우선순위를
선택하는 식으로 진행됩니다

782
00:41:02,300 --> 00:41:03,860
아시겠죠?

783
00:41:03,860 --> 00:41:04,860
질문해주셔서 감사합니다

784
00:41:04,860 --> 00:41:07,443
다른 질문 있나요?

785
00:41:09,320 --> 00:41:10,300
네

786
00:41:10,300 --> 00:41:19,350
예시에서 몇 단계만 한번
직접 해보도록 하겠습니다

787
00:41:19,350 --> 00:41:22,700
전체를 하지는 않겠습니다만

788
00:41:22,700 --> 00:41:27,860
다익스트라가 어떻게 동작하는지
알 수 있을 것입니다

789
00:41:27,860 --> 00:41:30,790
다익스트라의 초반부를 직접 해보는 건

790
00:41:30,790 --> 00:41:36,300
의미가 있다고 생각됩니다

791
00:41:36,300 --> 00:41:45,340
우선순위 큐가 어떻게
사용되는지 알 수 있겠죠

792
00:41:45,340 --> 00:41:48,740
정점이 5개 있는
방향 그래프를 보겠습니다

793
00:42:02,400 --> 00:42:04,550
여기는 7이고요

794
00:42:14,040 --> 00:42:18,760
A를 출발점으로 하여 시작해보겠습니다

795
00:42:18,760 --> 00:42:21,490
그러면 d[A]는 0이 되겠죠

796
00:42:21,490 --> 00:42:26,190
d[B]에서 d[E]까지는
모두 무한대일 것입니다

797
00:42:26,190 --> 00:42:31,580
S는 공집합으로 시작하고

798
00:42:31,580 --> 00:42:36,770
Q는 다섯 정점이
모두 들어있을 것입니다

799
00:42:39,710 --> 00:42:43,721
EXTRACT-MIN은
A를 선택할 것입니다

800
00:42:43,721 --> 00:42:46,830
A가 0인 유일한 정점이기 때문이죠

801
00:42:46,830 --> 00:42:51,550
0, ∞, ∞, ∞, ∞처럼 있으니까요

802
00:42:51,550 --> 00:42:56,130
선택했으면 S에 A를 넣어줍니다

803
00:42:56,130 --> 00:42:57,970
A를 넣어준 후에는

804
00:42:57,970 --> 00:42:59,640
A에서 나가는 간선에 대하여
완화해 줍니다

805
00:42:59,640 --> 00:43:01,000
두 개가 있죠

806
00:43:01,000 --> 00:43:07,010
그러면 0, 10, 3, ∞, ∞가
될 것입니다

807
00:43:07,010 --> 00:43:10,410
다음 EXTRACT-MIN은
3을 선택할 것입니다

808
00:43:10,410 --> 00:43:14,820
그리고 S를 {A, C}로 만들어줍니다

809
00:43:14,820 --> 00:43:16,570
그래서 어떻게 보면

810
00:43:16,570 --> 00:43:19,290
너비 우선 탐색을 한다고
볼 수도 있을 것 같습니다

811
00:43:19,290 --> 00:43:21,100
하지만 탐욕적으로 탐색하는 것이죠

812
00:43:21,100 --> 00:43:23,230
너비 우선 탐색과 깊이 우선 탐색을
섞어놓은 듯한 형태입니다

813
00:43:23,230 --> 00:43:24,730
너비 우선 탐색적인 면모는

814
00:43:24,730 --> 00:43:25,950
특정한 정점이 주어졌을 때

815
00:43:25,950 --> 00:43:27,408
그 정점으로 갈 수 있는

816
00:43:27,408 --> 00:43:29,320
모든 간선을 확인하는 데 있고

817
00:43:29,320 --> 00:43:31,810
그 후에는 탐욕 알고리즘이 적용됩니다

818
00:43:31,810 --> 00:43:34,710
이렇게 만든 최전선의 정점 중에서

819
00:43:34,710 --> 00:43:37,660
가장 가까운 곳
다시 말해

820
00:43:37,660 --> 00:43:40,350
우선순위가 가장 작은 정점을
선택합니다

821
00:43:40,350 --> 00:43:43,030
이 경우에서는 C가 되겠죠
왜냐하면 나머지는 10이고

822
00:43:43,030 --> 00:43:44,110
이것이 가장 작기 때문입니다

823
00:43:44,110 --> 00:43:44,610
이것이 가장 작기 때문입니다

824
00:43:44,610 --> 00:43:46,690
그래서 여기서 C를 고른 것입니다

825
00:43:46,690 --> 00:43:48,620
그리고 마지막 단계로

826
00:43:48,620 --> 00:43:52,940
C를 처리한 후에 해야 될 일은

827
00:43:52,940 --> 00:43:54,620
C에서 나가는 이 간선과

828
00:43:54,620 --> 00:43:55,840
이 간선

829
00:43:55,840 --> 00:43:57,560
이 간선에 대해 처리해주어야 합니다

830
00:43:57,560 --> 00:44:05,070
그러면 0, 7, 3, 11, 5가
될 것입니다

831
00:44:05,070 --> 00:44:08,280
C에서 나가는
많은 간선에 대해 처리했습니다

832
00:44:08,280 --> 00:44:11,730
이 시점에서는 0과 3이
처리가 완료되었습니다

833
00:44:11,730 --> 00:44:13,310
여기는 값들만 적고 있습니다

834
00:44:13,310 --> 00:44:14,890
어떤 정점을 의미하는지 아시겠죠

835
00:44:14,890 --> 00:44:17,670
이 정점들은 선택 대상이 아닙니다
왜냐하면 S에 있는 정점들은

836
00:44:17,670 --> 00:44:18,920
바뀌면 안 되기 때문입니다

837
00:44:18,920 --> 00:44:21,500
다익스트라가 보장하는 것이고

838
00:44:21,500 --> 00:44:23,100
이것이 타당성에 대한 증명입니다

839
00:44:23,100 --> 00:44:28,380
이 작업을 한다고 해서 이 값이

840
00:44:28,380 --> 00:44:29,620
더 줄어들지 않는다는 것입니다

841
00:44:29,620 --> 00:44:31,810
이 예비 값들은 더 줄어들지 않습니다

842
00:44:31,810 --> 00:44:33,710
그리고 S 안에 들어있죠

843
00:44:33,710 --> 00:44:35,800
이제 남은 것은 5입니다

844
00:44:35,800 --> 00:44:39,090
이는 정점 E에 대응합니다

845
00:44:39,090 --> 00:44:45,130
그러므로 S는 {A, C, E}가 됩니다

846
00:44:45,130 --> 00:44:46,970
5가 S에 들어가는 것입니다

847
00:44:46,970 --> 00:44:48,580
이런 식으로 진행합니다

848
00:44:48,580 --> 00:44:50,220
이런 식으로 진행합니다

849
00:44:50,220 --> 00:44:51,712
그래서 이것이 다익스트라입니다

850
00:44:51,712 --> 00:44:54,345
그럼 이제 복잡도에 대해 보겠습니다

851
00:44:55,630 --> 00:44:58,640
왼쪽에 다익스트라의 코드가 있고

852
00:44:58,640 --> 00:45:03,530
우선순위 큐로 나타내어지는
추상 자료형이 있습니다

853
00:45:03,530 --> 00:45:06,550
학기 초에 했던 이야기를
다시 해보도록 하겠습니다

854
00:45:06,550 --> 00:45:11,410
연결 리스트를 배열, 힙, 트리와
비교하면서 했던 이야기들 말입니다

855
00:45:11,410 --> 00:45:15,170
연결 리스트를 배열, 힙, 트리와
비교하면서 했던 이야기들 말입니다

856
00:45:15,170 --> 00:45:21,580
특정한 연산에 대하여

857
00:45:21,580 --> 00:45:24,020
어떤 것이 더 나을지 보겠습니다

858
00:45:24,020 --> 00:45:25,130
어떤 것이 더 나을지 보겠습니다

859
00:45:25,130 --> 00:45:29,100
먼저 다익스트라의 의사 코드를
보도록 하겠습니다

860
00:45:29,100 --> 00:45:37,790
어떠한 연산을 하고 있나요?

861
00:45:37,810 --> 00:45:43,440
이 연산은 θ(V)만큼
우선순위 큐에 삽입합니다

862
00:45:43,440 --> 00:45:53,740
이 연산은 θ(V)만큼
우선순위 큐에 삽입합니다

863
00:45:53,760 --> 00:45:57,440
Q에 원소를 삽입하는 것입니다

864
00:45:57,440 --> 00:46:08,280
θ(V)번 EXTRACT-MIN 연산을 합니다

865
00:46:08,290 --> 00:46:11,070
정점은 한 번씩만 삭제되고
처리되기 때문에

866
00:46:11,070 --> 00:46:12,160
정점은 한 번씩만 삭제되고
처리되기 때문에

867
00:46:12,160 --> 00:46:15,780
정확히 θ(V)만큼의
연산이 이루어지는 것입니다

868
00:46:15,780 --> 00:46:22,840
그리고 θ(E)만큼의 키 감소
혹은 갱신 연산이 있습니다

869
00:46:22,840 --> 00:46:29,690
왜냐하면 여기서 완화를 진행할 때

870
00:46:29,690 --> 00:46:34,720
키를 감소시키는 것이기 때문입니다

871
00:46:34,720 --> 00:46:36,510
자세히는 키 갱신은 아닙니다

872
00:46:36,510 --> 00:46:39,329
키 감소 연산이 되겠죠
별 상관은 없지만요

873
00:46:39,329 --> 00:46:40,620
이를 자세히 다를 필요는 없습니다만

874
00:46:40,620 --> 00:46:42,530
d 값을 줄이고 있기 때문입니다

875
00:46:42,530 --> 00:46:45,040
그래서 키 감소 연산이 되고

876
00:46:45,040 --> 00:46:51,295
θ(E)가 되는 이유는 방향 그래프에서

877
00:46:51,295 --> 00:46:53,170
정점에서 나오는 간선들을

878
00:46:53,170 --> 00:46:55,512
딱 한 번만 처리하기 때문입니다

879
00:46:55,512 --> 00:46:57,220
정점들을 한 번씩만 처리하고

880
00:46:57,220 --> 00:46:59,930
그 정점의 모든 진출 간선에 대해
처리하기 때문입니다

881
00:46:59,930 --> 00:47:01,470
그 정점의 모든 진출 간선에 대해
처리하기 때문입니다

882
00:47:01,470 --> 00:47:02,530
그 정점의 모든 진출 간선에 대해
처리하기 때문입니다

883
00:47:02,530 --> 00:47:06,340
그래서 의사 코드를 보고
이런 것들을 알아낼 수 있고요

884
00:47:06,340 --> 00:47:09,230
이제 자료 구조 설계자로서

885
00:47:09,230 --> 00:47:12,120
몇 가지 선택을 할 수 있겠죠

886
00:47:12,120 --> 00:47:14,910
우선순위 큐를 어떻게 구현할지요

887
00:47:14,910 --> 00:47:21,030
배열로 했을 때 다익스트라의
복잡도를 보겠습니다

888
00:47:21,030 --> 00:47:25,420
우선순위 큐로 배열 구조를
이용하게 되었다면

889
00:47:25,420 --> 00:47:28,040
우선순위 큐로 배열 구조를
이용하게 되었다면

890
00:47:28,040 --> 00:47:31,800
어떤 연산을 해야 하나요?

891
00:47:31,800 --> 00:47:37,570
EXTRACT-MIN을 봅시다

892
00:47:37,570 --> 00:47:40,720
배열에서 EXTRACT-MIN의
복잡도는 어떻게 되나요?

893
00:47:40,720 --> 00:47:41,540
학생: θ(V)입니다

894
00:47:41,540 --> 00:47:44,270
θ(V)죠
그러면 배열에서

895
00:47:44,270 --> 00:47:48,290
키 감소의 복잡도는 어떻게 되나요?

896
00:47:48,290 --> 00:47:50,210
배열의 원소에 접근해서

897
00:47:50,210 --> 00:47:51,600
바꾸면 됩니다

898
00:47:51,600 --> 00:47:53,140
θ(1) 맞나요?

899
00:47:53,140 --> 00:47:59,010
그래서 EXTRACT-MIN은
θ(V)가 되고

900
00:47:59,010 --> 00:48:00,810
그냥 EX-MIN이라고 부르겠습니다

901
00:48:00,810 --> 00:48:06,750
키 감소는 θ(1)이 됩니다

902
00:48:06,750 --> 00:48:09,890
그리고 곱셈을 해보면

903
00:48:09,890 --> 00:48:17,290
θ(V·V+E·1)이 되고

904
00:48:17,290 --> 00:48:19,860
이는 θ(V^2)가 됩니다

905
00:48:19,860 --> 00:48:23,260
E가 O(V^2)이기 때문입니다

906
00:48:23,260 --> 00:48:23,760
E가 O(V^2)이기 때문입니다

907
00:48:23,760 --> 00:48:27,100
단순 그래프가 있다면
완전 그래프일 수도 있지만

908
00:48:27,100 --> 00:48:29,460
예전에 말했던 것처럼

909
00:48:29,460 --> 00:48:31,810
E는 대부분의 경우 V^2이 됩니다

910
00:48:31,810 --> 00:48:34,445
그래서 그냥 θ(V^2)라고 하겠습니다

911
00:48:34,445 --> 00:48:35,340
그래서 그냥 θ(V^2)라고 하겠습니다

912
00:48:35,340 --> 00:48:39,000
그래서 배열을 사용하는 복잡도 θ(V^2)의
다익스트라 구현이 있습니다

913
00:48:39,000 --> 00:48:42,012
그래서 배열을 사용하는 복잡도 θ(V^2)의
다익스트라 구현이 있습니다

914
00:48:42,012 --> 00:48:43,720
배열 구조를 사용하는 것이 좋을까요?

915
00:48:43,720 --> 00:48:49,290
어떤 자료 구조를 사용해야 할까요?

916
00:48:49,290 --> 00:48:50,200
네

917
00:48:50,200 --> 00:48:50,829
학생: 힙이요

918
00:48:50,829 --> 00:48:52,370
최소 힙을 이용할 수 있습니다

919
00:48:52,370 --> 00:48:53,990
정확합니다

920
00:48:53,990 --> 00:49:00,840
이진 최소 힙을 사용하게 된다면

921
00:49:00,840 --> 00:49:16,830
EXTRACT-MIN을 살펴보자면
최소를 찾는 것은 상수 시간이 될 것입니다

922
00:49:16,830 --> 00:49:18,910
위에서 바로 고르면 되니까요

923
00:49:18,910 --> 00:49:22,770
하지만 힙을 갱신하고

924
00:49:22,770 --> 00:49:28,220
지우고 싶다면 θ(log V)의
시간이 걸릴 것입니다

925
00:49:28,220 --> 00:49:31,460
키 감소도 마찬가지겠죠

926
00:49:31,460 --> 00:49:37,886
θ(log V)죠
이 연산은 배열보다 안 좋습니다

927
00:49:37,886 --> 00:49:40,000
그리고 곱셈을 다시 해보면

928
00:49:40,000 --> 00:49:45,920
V log V + E log V가 됩니다

929
00:49:45,920 --> 00:49:49,590
기억하시는 분이 있는지는 모르겠지만

930
00:49:49,590 --> 00:49:54,330
이는 예전에 알려드렸던
복잡도가 아닙니다

931
00:49:54,330 --> 00:49:57,790
이는 다익스트라의
최선의 복잡도가 아닙니다

932
00:49:57,790 --> 00:50:01,280
이는 다익스트라의
최선의 복잡도가 아닙니다

933
00:50:01,280 --> 00:50:05,800
특정한 자료 구조를 이용하면
이 log V를 없앨 수 있는데

934
00:50:05,800 --> 00:50:08,460
이는 6.006에서는
배우지 않을 것입니다

935
00:50:08,460 --> 00:50:11,190
하지만 읽어보시면 될 것 같습니다

936
00:50:11,190 --> 00:50:15,660
6.006의 범위를 넘어섭니다

937
00:50:15,660 --> 00:50:18,410
6.006에서 알 필요는 없지만

938
00:50:18,410 --> 00:50:20,480
피보나치 힙이라고 합니다

939
00:50:20,480 --> 00:50:22,780
6.046 과목에서
배우실 수 있을 것입니다

940
00:50:22,780 --> 00:50:27,440
피보나치 힙은 분할 상환 자료 구조로

941
00:50:27,440 --> 00:50:31,980
EXTRACT-MIN을 θ(log V) 만에
할 수 있습니다

942
00:50:31,980 --> 00:50:43,090
키 감소는 θ(1) 분할 상환 시간 만에
가능합니다

943
00:50:43,090 --> 00:50:44,890
이것의 멋진 점은

944
00:50:44,890 --> 00:50:52,320
이를 이용하면 θ(V log V + E)
시간 만에 할 수 있습니다

945
00:50:52,320 --> 00:50:56,850
이것이 예전에 알려드렸었던 복잡도입니다

946
00:50:56,850 --> 00:50:59,610
아마 전 주 목요일이었을 겁니다

947
00:50:59,610 --> 00:51:04,000
그래서 여기까지가
두 특수한 경우에 대한 이야기였습니다

948
00:51:04,000 --> 00:51:08,930
DAG에서는 기본적으로
선형 시간에 가능했고

949
00:51:08,930 --> 00:51:13,420
다익스트라는 분할 상환과
적절한 자료 구조를 이용해

950
00:51:13,420 --> 00:51:16,101
마찬가지로 선형 시간에 가능했습니다

951
00:51:16,101 --> 00:51:16,600
마찬가지로 선형 시간에 가능했습니다

952
00:51:16,600 --> 00:51:18,308
다음 시간에는
음의 순환이 있을 수도 있는

953
00:51:18,308 --> 00:51:20,550
일반적인 경우에 대해 살펴보겠습니다

954
00:51:20,550 --> 00:51:24,070
더 큰 복잡도를 갖는
알고리즘이 될 것입니다

955
00:51:24,070 --> 00:51:26,220
다음 시간에 봅시다
