1
00:00:00,050 --> 00:00:01,770
본 저작물은 크리에이티브 커먼즈
라이선스를 따르고 있습니다

2
00:00:01,770 --> 00:00:04,010
본 저작물은 크리에이티브 커먼즈
라이선스를 따르고 있습니다

3
00:00:04,010 --> 00:00:06,860
여러분의 후원이 
MIT OpenCourseWare가

4
00:00:06,860 --> 00:00:10,720
지속적으로 고품질의 교육 자료를 
무료로 제공하는 데에 큰 도움이 됩니다

5
00:00:10,720 --> 00:00:13,320
후원을 하시거나

6
00:00:13,320 --> 00:00:17,207
더 많은 MIT 강의 자료를 찾으시려면

7
00:00:17,207 --> 00:00:22,132
ocw.mit.edu 를 방문해 주세요

8
00:00:22,770 --> 00:00:25,770
앞으로 몇 번의 수업에 걸쳐
최단 경를 배울 예정입니다

9
00:00:25,770 --> 00:00:32,310
앞으로 몇 번의 수업에 걸쳐
최단 경를 배울 예정입니다

10
00:00:32,310 --> 00:00:36,380
수학적인 관점에서 
지난 강의와 큰 차이가 있는데

11
00:00:36,380 --> 00:00:39,930
수학적인 관점에서 
지난 강의와 큰 차이가 있는데

12
00:00:39,930 --> 00:00:44,780
이번에는 간선에 
가중치가 있다는 점입니다

13
00:00:44,780 --> 00:00:47,690
저번 몇 개의 수업에서 Eric이
깊이 우선 탐색과

14
00:00:47,690 --> 00:00:50,140
너비 우선 탐색에 대한 내용을
다루었을 때

15
00:00:50,140 --> 00:00:54,160
방향 그래프와 무방향 그래프를
살펴보았는데

16
00:00:54,160 --> 00:00:57,270
그때는 간선에
어떠한 특징도 없었습니다

17
00:00:57,270 --> 00:01:00,690
특별히 그래프의 간선에
가중치를 부여하게 된다면

18
00:01:00,690 --> 00:01:03,190
더 다양한 종류의 문제와
적용이 가능할 것입니다

19
00:01:03,190 --> 00:01:07,700
더 다양한 종류의 문제와
적용이 가능할 것입니다

20
00:01:07,700 --> 00:01:13,020
이 가중치라는 것은 정수일 수도 있고

21
00:01:13,020 --> 00:01:15,270
실수일 수도, 유리수일 수도

22
00:01:15,270 --> 00:01:17,560
음수일 수도 있습니다

23
00:01:17,560 --> 00:01:22,030
그래프의 종류와

24
00:01:22,030 --> 00:01:25,790
가중치에 대한 제약들에 따라

25
00:01:25,790 --> 00:01:29,460
저희가 다음 몇 강의에 걸쳐 배울

26
00:01:29,460 --> 00:01:33,150
최단 경로 알고리즘들은

27
00:01:33,150 --> 00:01:37,050
특정한 상황에 맞게
최적화되어 있습니다

28
00:01:37,050 --> 00:01:41,900
오늘은 어떤 특정한 알고리즘을
배우지는 않을 것이지만

29
00:01:41,900 --> 00:01:43,770
문제 상황을 설정할 것입니다

30
00:01:43,770 --> 00:01:46,050
그리고 일반적으로 대부분의
최단 경로 알고리즘이

31
00:01:46,050 --> 00:01:48,970
특정한 경우의 문제를 해결하기 위해서

32
00:01:48,970 --> 00:01:52,010
어떠한 방법으로 접근하는지
알아볼 것입니다

33
00:01:52,010 --> 00:01:56,810
그리고 최적해와
최적 부분 구조 조건이라고 불리는

34
00:01:56,810 --> 00:01:59,390
상당히 중요한 성질에 대해서
이야기하고 수업을 마칠 것입니다

35
00:01:59,390 --> 00:02:03,290
상당히 중요한 성질에 대해서
이야기하고 수업을 마칠 것입니다

36
00:02:03,290 --> 00:02:06,904
이는 대부분의 최단 경로 알고리즘이

37
00:02:06,904 --> 00:02:08,570
효율적인 복잡도를 얻기 위해
이용하는 기법입니다

38
00:02:08,570 --> 00:02:14,690
효율적인 복잡도를 얻기 위해
이용하는 기법입니다

39
00:02:14,690 --> 00:02:18,890
당연하지만
점근적인 복잡도가 중요합니다

40
00:02:18,890 --> 00:02:22,580
그리고 우리는 항상 가장 효율적인

41
00:02:22,580 --> 00:02:23,930
점근적 복잡도를 가지는
알고리즘을 원합니다

42
00:02:23,930 --> 00:02:26,710
그리고 그를 얻기 위해 사용하는 도구가
최적 부분 구조입니다

43
00:02:26,710 --> 00:02:30,990
그리고 그를 얻기 위해 사용하는 도구가
최적 부분 구조입니다

44
00:02:30,990 --> 00:02:35,850
최단 경로를 찾는 정통적인 동기는

45
00:02:35,850 --> 00:02:38,010
대포를 칼텍으로부터 훔쳐서

46
00:02:38,010 --> 00:02:40,640
아니, 빌려서 MIT로
가져오려고 할 때

47
00:02:40,640 --> 00:02:43,860
아니, 빌려서 MIT로
가져오려고 할 때

48
00:02:43,860 --> 00:02:52,510
그 불법적인 물건을 가져올 수 있는
가장 빠른 길을 택하고 싶을 겁니다

49
00:02:52,510 --> 00:02:56,230
그러기 위해서 한 장소에서
다른 장소로 갈 수 있는

50
00:02:56,230 --> 00:02:59,080
가장 짧은 혹은 빠른 길을 원할 겁니다

51
00:02:59,080 --> 00:03:03,500
구글맵이 A 지점에서 B 지점으로
가는 길을 찾는 것이

52
00:03:03,500 --> 00:03:09,210
전형적인 최단 경로 문제입니다

53
00:03:09,210 --> 00:03:13,000
이와 같은 경우에는 거리가

54
00:03:13,000 --> 00:03:16,110
간선의 가중치로 설정할 수 있는
간단한 기준이 될 것입니다

55
00:03:16,110 --> 00:03:19,120
간선의 가중치로 설정할 수 있는
간단한 기준이 될 것입니다

56
00:03:19,120 --> 00:03:23,360
이 과목 전체에서 저희는

57
00:03:23,360 --> 00:03:31,390
그래프 G(V, E, W)를 살펴볼 것입니다

58
00:03:31,390 --> 00:03:32,660
V와 E는 여러분이 아시는 대로

59
00:03:32,660 --> 00:03:38,360
정점과 간선을 나타냅니다

60
00:03:38,360 --> 00:03:47,020
그리고 W는 각 간선의 가중치를 나타내는
가중치 함수입니다

61
00:03:47,020 --> 00:03:50,510
그 함수를 여기에 추가해주었습니다

62
00:03:50,510 --> 00:03:59,140
그러면 W는 E에서 실수 집합 R로 가는
함수가 될 것입니다

63
00:03:59,140 --> 00:04:02,990
저희는 다음 강의에 걸쳐 두 가지의
다른 알고리즘을 살펴볼 것입니다

64
00:04:02,990 --> 00:04:04,630
저희는 다음 강의에 걸쳐 두 가지의
다른 알고리즘을 살펴볼 것입니다

65
00:04:04,630 --> 00:04:10,395
그리고 연습 문제로
둘 중 하나를 구현해 볼 것입니다

66
00:04:10,395 --> 00:04:15,030
먼저 살펴볼
조금 더 간단한 알고리즘은

67
00:04:15,030 --> 00:04:18,510
에츠허르 다익스트라의 이름을 따
다익스트라라고 불립니다

68
00:04:18,510 --> 00:04:21,970
병행 프로그래밍에서도 비슷한 일을 해
튜링상을 받았습니다

69
00:04:21,970 --> 00:04:23,320
병행 프로그래밍에서도 비슷한 일을 해
튜링상을 받았습니다

70
00:04:23,320 --> 00:04:26,790
그리고 다익스트라라고 불리는
멋진 알고리즘을 개발했습니다

71
00:04:26,790 --> 00:04:30,330
아니면 적어도 개발했다고
인정을 받고 있습니다

72
00:04:30,330 --> 00:04:36,530
이 알고리즘은
음수가 아닌 가중치를 가정합니다

73
00:04:36,530 --> 00:04:38,030
음수가 아닌 가중치를 가진
간선이라고 생각하세요

74
00:04:38,030 --> 00:04:40,690
음수가 아닌 가중치를 가진
간선이라고 생각하세요

75
00:04:40,690 --> 00:04:51,510
그리고 이 알고리즘은
O(V logV + E)의 복잡도를 가집니다

76
00:04:51,510 --> 00:04:52,290
그리고 이 알고리즘은
O(V logV + E)의 복잡도를 가집니다

77
00:04:52,290 --> 00:04:58,340
실질적으로 이는
선형 시간인 알고리즘이고

78
00:04:58,340 --> 00:05:01,910
많은 경우에 보통
E 항이 지배적일 겁니다

79
00:05:01,910 --> 00:05:10,060
일반적으로 단순 그래프를 생각했을 때

80
00:05:10,060 --> 00:05:13,690
E와 V의 점근적인 관계는
어떻게 되나요?

81
00:05:19,430 --> 00:05:21,040
E와 V를 연관 지을 수 있나요?

82
00:05:21,040 --> 00:05:22,874
어떠한 범위 내에 있나요?

83
00:05:22,874 --> 00:05:23,942
학생: V 제곱이요

84
00:05:23,942 --> 00:05:24,650
네 V 제곱입니다
감사합니다

85
00:05:24,650 --> 00:05:25,970
네 V 제곱입니다
감사합니다

86
00:05:25,970 --> 00:05:27,700
잘했어요

87
00:05:27,700 --> 00:05:33,280
E를 O(V²)으로 생각할 수 있습니다

88
00:05:33,280 --> 00:05:41,300
네, 그 사실을 짚고 넘어가도록 하겠습니다

89
00:05:41,310 --> 00:05:44,540
이번에는
완전 그래프를 떠올려 보세요

90
00:05:44,540 --> 00:05:46,390
완전 그래프는 모든 정점 사이에
간선이 존재하는 그래프입니다

91
00:05:46,390 --> 00:05:52,980
완전 그래프는 모든 정점 사이에
간선이 존재하는 그래프입니다

92
00:05:52,980 --> 00:05:57,710
그 그래프가
E가 V의 제곱이 되는 경우일 것입니다

93
00:05:57,710 --> 00:05:59,370
단순 그래프는 두 정점 사이에
최대 하나의 간선이 있습니다

94
00:05:59,370 --> 00:06:03,630
단순 그래프는 두 정점 사이에
최대 하나의 간선이 있습니다

95
00:06:03,630 --> 00:06:05,160
다중 그래프는 두 정점 사이에
여러 간선이 존재할 수 있습니다

96
00:06:05,160 --> 00:06:08,140
다중 그래프는 두 정점 사이에
여러 간선이 존재할 수 있습니다

97
00:06:08,140 --> 00:06:10,480
이 수업에서는 다중 그래프에 대해
다루지 않을 예정이지만

98
00:06:10,480 --> 00:06:12,840
이 수업에서는 다중 그래프에 대해
다루지 않을 예정이지만

99
00:06:12,840 --> 00:06:19,420
이와 같은 알고리즘들을 배우면서
한번쯤 생각해보셨으면 좋겠습니다

100
00:06:19,420 --> 00:06:21,130
이와 같은 알고리즘들을 배우면서
한번쯤 생각해보셨으면 좋겠습니다

101
00:06:21,130 --> 00:06:25,810
많은 경우에 여기서
가장 지배적인 요인은 E입니다

102
00:06:25,810 --> 00:06:30,390
그렇기 때문에 간선에 대해 선형인
다익스트라가 좋은 알고리즘일 수 있는 것입니다

103
00:06:30,390 --> 00:06:34,050
따라서 간선에 대해 선형인
다익스트라는 좋은 알고리즘입니다

104
00:06:34,050 --> 00:06:38,090
그리고 다익스트라가 다음 시간에 볼
첫 알고리즘이 될 것입니다

105
00:06:38,090 --> 00:06:40,750
그리고 다익스트라가 다음 시간에 볼
첫 알고리즘이 될 것입니다

106
00:06:40,750 --> 00:06:44,070
오늘은 다익스트라의
전반적인 구조에 대해서만 다룰 것입니다

107
00:06:44,070 --> 00:06:50,880
벨만-포드 알고리즘이라는
것도 있는데

108
00:06:50,880 --> 00:06:56,890
양수인 가중치뿐만 아니라
음수인 가중치에 대해서도 작동하며

109
00:06:56,890 --> 00:07:03,630
O(VE)의 복잡도를 갖습니다

110
00:07:03,630 --> 00:07:06,240
그래서 벨만-포드의
특정한 구현에 대해서 생각해보면

111
00:07:06,240 --> 00:07:10,060
O(V^3)이 될 것입니다

112
00:07:10,060 --> 00:07:12,360
왜냐하면 E는 V^2이고

113
00:07:12,360 --> 00:07:14,610
E가 추가로 곱해져 있기 때문에

114
00:07:14,610 --> 00:07:17,800
O(V^3)과 O(V log V)를
비교하는 것이 됩니다

115
00:07:17,800 --> 00:07:21,000
그래서 쓸 수만 있다면
다익스트라를 사용하세요

116
00:07:21,000 --> 00:07:25,670
하지만 다른 방법이 없을 때는
벨만-포드를 사용해야 합니다

117
00:07:25,670 --> 00:07:27,665
음수인 가중치를 가진
간선이 있는 경우에 말이죠

118
00:07:27,665 --> 00:07:29,790
그리고 이런 음의 가중치를 갖는
간선이 있는 것이 어려운 점 중 하나는

119
00:07:29,790 --> 00:07:32,550
진행하면서
더 이야기하게 될 것이지만

120
00:07:32,550 --> 00:07:37,050
최종적으로 음의 가중치를 가지는 순환을
찾아야 한다는 점입니다

121
00:07:37,050 --> 00:07:41,720
최종적으로 음의 가중치를 가지는 순환을
찾아야 한다는 점입니다

122
00:07:41,720 --> 00:07:44,840
왜냐하면 이가 계속해서
짧은 경로를 찾으려는

123
00:07:44,840 --> 00:07:49,590
최단 경로 알고리즘의
허를 찌르기 때문입니다.

124
00:07:49,590 --> 00:07:51,180
최단 경로 알고리즘의
허를 찌르기 때문입니다.

125
00:07:51,180 --> 00:07:55,460
하지만 음의 순환을 찾으면
그 경로를 한 번 도는 것으로

126
00:07:55,460 --> 00:07:57,900
전체 가중치를 줄일 수 있게 됩니다

127
00:07:57,900 --> 00:08:01,150
그래서 지나온 간선의 수로 따졌을 때
더 길었던 경로의

128
00:08:01,150 --> 00:08:02,600
가중치가 더 작게 되는 일이 발생합니다

129
00:08:02,600 --> 00:08:05,970
그리고 이런 종류의 문제가
알고리즘을 더 복잡하게 만듭니다

130
00:08:05,970 --> 00:08:07,362
더 많은 연산도 따르고요

131
00:08:07,362 --> 00:08:09,820
그것이 이 두 알고리즘의
복잡도에 차이가 생기는 이유입니다

132
00:08:09,820 --> 00:08:10,760
그것이 이 두 알고리즘의
복잡도에 차이가 생기는 이유입니다

133
00:08:10,760 --> 00:08:14,200
그리고 이에 대한 내용은

134
00:08:14,200 --> 00:08:16,700
다익스트라와 벨만-포드 알고리즘의
학습 후에 잘 이해하게 될 것입니다

135
00:08:16,700 --> 00:08:20,019
다익스트라와 벨만-포드 알고리즘의
학습 후에 잘 이해하게 될 것입니다

136
00:08:20,019 --> 00:08:21,560
여기까지가 문제 상황을
정의하는 것이었습니다

137
00:08:21,560 --> 00:08:24,030
저희가 앞으로 배워나갈 것들입니다

138
00:08:24,030 --> 00:08:27,830
여기까지 했던 것에 더해

139
00:08:27,830 --> 00:08:34,549
표기에 관한 정의를
더 살펴보겠습니다

140
00:08:34,549 --> 00:08:46,883
경로 p를 정점들의 나열인
V0, V1, ..., Vk로 생각할 수 있습니다

141
00:08:46,883 --> 00:08:49,880
경로 p는 정점들의 나열
V0, V1, ..., Vk로 볼 수 있습니다

142
00:08:49,880 --> 00:08:57,650
이것이 경로가 되려면 (Vi, Vi+1)이
E에 속해야 합니다

143
00:08:57,650 --> 00:09:03,320
0 이상 k 미만인 i에 대해 말이죠

144
00:09:03,320 --> 00:09:05,210
0 이상 k 미만인 i에 대해 말이죠

145
00:09:05,210 --> 00:09:08,290
그래서 경로는 간선의 나열입니다

146
00:09:08,290 --> 00:09:10,670
그리고 각 간선은
그래프에 존재해야 합니다

147
00:09:10,670 --> 00:09:15,530
간선의 집합 E의 원소이어야 합니다

148
00:09:15,530 --> 00:09:20,090
경로의 가중치는 W(p)로 나타냅니다

149
00:09:20,090 --> 00:09:22,860
간선의 가중치는 이미 알고 있습니다

150
00:09:22,860 --> 00:09:24,970
W 함수로 주어져 있죠

151
00:09:24,970 --> 00:09:27,840
경로의 가중치는 간단하게

152
00:09:27,840 --> 00:09:33,100
간선의 가중치들의 합입니다

153
00:09:33,100 --> 00:09:33,620
네, 정말로 당연한 정의입니다

154
00:09:33,620 --> 00:09:35,610
네, 정말로 당연한 정의입니다

155
00:09:35,610 --> 00:09:37,730
하지만 올바른 문제해결을 위해
잘 알아둬야 합니다

156
00:09:37,730 --> 00:09:43,030
하지만 올바른 문제해결을 위해
잘 알아둬야 합니다

157
00:09:43,030 --> 00:09:49,760
그리고 최단 경로 문제는 예상하시다시피

158
00:09:49,760 --> 00:10:00,050
가중치가 최소인 경로 p를
찾으려고 하는 것입니다

159
00:10:00,050 --> 00:10:03,840
그래서 일반적으로
문제 상황이 정해져 있을 때

160
00:10:03,840 --> 00:10:13,250
가중치가 최소인 경로
p를 찾는 문제입니다

161
00:10:13,260 --> 00:10:16,599
가능한 경로는 많을 것입니다

162
00:10:16,599 --> 00:10:18,640
그래프에는 저희가 고려해야 할
지수적인 수의 경로가 존재합니다

163
00:10:18,640 --> 00:10:22,082
그래프에는 저희가 고려해야 할
지수적인 수의 경로가 존재합니다

164
00:10:22,082 --> 00:10:23,040
그래프에는 저희가 고려해야 할
지수적인 수의 경로가 존재합니다

165
00:10:23,040 --> 00:10:26,610
지수적인 경로가 존재하는 
그래프의 예를 봅시다

166
00:10:26,610 --> 00:10:33,360
지수적인 경로가 존재하는 
그래프의 예를 봅시다

167
00:10:33,360 --> 00:10:38,540
나중에 다시 이 예제를 볼 것입니다

168
00:10:38,540 --> 00:10:44,060
이 방향으로만 갈 수 있는
방향 그래프가 있다고 가정해봅시다

169
00:10:44,060 --> 00:10:46,500
이 방향으로만 갈 수 있는
방향 그래프가 있다고 가정해봅시다

170
00:10:46,500 --> 00:10:49,245
이렇게 쭉 갈 수 있는 경로도 있고

171
00:10:49,245 --> 00:10:52,220
위를 거쳐서 가다가

172
00:10:52,220 --> 00:10:53,700
이렇게 가는 경로도 있을 수 있습니다

173
00:10:53,700 --> 00:10:57,510
이 정점으로 가는 데에는
두 가지 방법이 있을 겁니다

174
00:10:57,510 --> 00:10:59,190
그리고 그 두 가지 경로로부터

175
00:10:59,190 --> 00:11:01,320
이 정점까지 가는 데는

176
00:11:01,320 --> 00:11:03,580
네 가지 방법이 있습니다

177
00:11:03,580 --> 00:11:06,240
이어서, 여기까지 오는 데는
여덟 가지 방법이 있습니다

178
00:11:06,240 --> 00:11:07,870
이런 식으로 계속되는 거죠

179
00:11:07,870 --> 00:11:10,750
그래서 가능한 경로는 지수적일 것입니다

180
00:11:10,750 --> 00:11:12,970
복잡도 측면에서 중요한
다른 흥미로운 점이 있습니다

181
00:11:12,970 --> 00:11:15,900
복잡도 측면에서 중요한
다른 흥미로운 점이 있습니다

182
00:11:15,900 --> 00:11:19,580
흥미로운 점이 무엇일까요?

183
00:11:19,580 --> 00:11:23,380
흥미로운 점이 무엇일까요?

184
00:11:23,380 --> 00:11:25,590
무언가 떠오르는 점이 있으신가요?

185
00:11:25,590 --> 00:11:30,910
여기서는 이 복잡도를 가지고
저기서는 O(VE)의 복잡도를 가지는데

186
00:11:30,910 --> 00:11:34,762
칠판의 이 부분과 두 복잡도를 보았을 때
무언가 흥미로운 점이 보이나요?

187
00:11:34,762 --> 00:11:40,635
칠판의 이 부분과 두 복잡도를 보았을 때
무언가 흥미로운 점이 보이나요?

188
00:11:40,635 --> 00:11:41,810
누구 있나요?

189
00:11:41,810 --> 00:11:42,580
네, 거기 학생

190
00:11:42,580 --> 00:11:44,330
- 가중치의 함수가 아닙니다

191
00:11:44,330 --> 00:11:45,690
가중치의 함수가 아니다

192
00:11:45,690 --> 00:11:46,190
잘했습니다

193
00:11:46,190 --> 00:11:48,650
다시 상기시킬 필요가 있습니다

194
00:11:48,650 --> 00:11:53,130
이걸 한번 던져보세요

195
00:11:53,130 --> 00:11:55,990
저기 뒤에 보이는 데까지

196
00:11:55,990 --> 00:11:57,900
저기 뒤에 보이는 데까지

197
00:11:57,900 --> 00:11:58,580
네, 잘하셨어요

198
00:11:58,580 --> 00:11:59,537
네, 잘하셨어요

199
00:11:59,537 --> 00:12:00,120
네, 잘하셨어요

200
00:12:00,120 --> 00:12:01,450
제가 던지는 것보다 낫군요

201
00:12:01,450 --> 00:12:02,180
아뇨 딱히 그렇진 않은 것 같네요

202
00:12:02,180 --> 00:12:09,390
저라면 손으로 정확히 전달했을 건데요

203
00:12:09,390 --> 00:12:12,940
아무튼, 사실 방금 그 대답은
좋은 관찰이었습니다

204
00:12:12,940 --> 00:12:14,940
제가 앞부분에서 지적했어야 했는데

205
00:12:14,940 --> 00:12:17,880
말해주셔서 감사합니다

206
00:12:17,880 --> 00:12:22,160
W는 복잡도에 영향을 미치지 않습니다

207
00:12:22,160 --> 00:12:23,650
이건 상당히 중요한 이야기입니다

208
00:12:23,650 --> 00:12:26,410
W는 아주 큰 수일 수도 있습니다

209
00:12:26,410 --> 00:12:29,030
2^64처럼 아주 클 수도 있죠

210
00:12:29,030 --> 00:12:34,640
하지만 가중치는 E 제곱 개의
다른 값만을 가질 수가 있습니다

211
00:12:34,640 --> 00:12:37,170
하지만 가중치는 E²개의
다른 값만을 가질 수가 있습니다

212
00:12:37,170 --> 00:12:38,730
대략적으로 말하자면 그렇습니다

213
00:12:38,730 --> 00:12:41,390
완전 그래프를 생각하면
그것은 단순 그래프이고

214
00:12:41,390 --> 00:12:45,160
O(E^2)개의 가능한 가중치가 있겠죠

215
00:12:45,160 --> 00:12:49,830
하지만 가중치의 범위는
지수적일 수도 있습니다

216
00:12:49,830 --> 00:12:54,480
0.0001의 가중치를 가지는
간선이 있을 수도 있고

217
00:12:54,480 --> 00:12:58,090
10^98의 가중치를 가지는
간선이 있을 수도 있습니다

218
00:12:58,090 --> 00:13:01,190
가중치를 그렇게 설정하거나

219
00:13:01,190 --> 00:13:04,040
그런 조건을 붙이는 건
아무런 상관이 없습니다

220
00:13:04,040 --> 00:13:06,830
다익스트라와 벨만-포드

221
00:13:06,830 --> 00:13:09,030
그리고 다른 실제로 사용되는
알고리즘들의 장점으로

222
00:13:09,030 --> 00:13:10,960
그리고 다른 실제로 사용되는
알고리즘들의 장점으로

223
00:13:10,960 --> 00:13:15,450
가중치의 범위와 상관없이
작동할 수 있다는 점이 있습니다

224
00:13:15,450 --> 00:13:17,720
최단 경로 알고리즘이
그렇다는 점을 기억해 두세요

225
00:13:17,720 --> 00:13:19,622
최단 경로 알고리즘이
그렇다는 점을 기억해 두세요

226
00:13:19,622 --> 00:13:22,080
이와 관련해서는 내일 섹션에서
조금 더 다뤄볼 것입니다

227
00:13:22,080 --> 00:13:26,390
또는 조교가 너비 우선 탐색과
깊이 우선 탐색이

228
00:13:26,390 --> 00:13:30,380
최단 경로 문제에 적용이
불가능한지 설명할 것입니다

229
00:13:30,380 --> 00:13:31,610
최단 경로 문제에 적용이
불가능한지 설명할 것입니다

230
00:13:31,610 --> 00:13:36,480
그 실마리는 가중치의 동적 범위입니다

231
00:13:36,480 --> 00:13:37,770
그 점을 기억해 두세요

232
00:13:37,770 --> 00:13:40,970
그래서 이것이 왜 흥미로운 알고리즘이고

233
00:13:40,970 --> 00:13:44,310
풀기에 흥미로운 문제이며

234
00:13:44,310 --> 00:13:47,070
예전에 봤던 정렬과
검색 문제보다 어려운가 하면

235
00:13:47,070 --> 00:13:49,760
경로의 수가 지수적으로
존재하기 때문입니다

236
00:13:49,760 --> 00:13:51,540
그리고 가중치가 굉장히
넓은 범위에 걸쳐 있을 수 있기 때문입니다

237
00:13:51,540 --> 00:13:53,700
그리고 가중치가 굉장히
넓은 범위에 걸쳐 있을 수 있기 때문입니다

238
00:13:53,700 --> 00:13:55,520
그리고 그것이 선형적이지도 않죠

239
00:13:55,520 --> 00:13:58,940
이런 알고리즘들의 영리한 부분과

240
00:13:58,940 --> 00:14:00,875
최적 부분 구조에 대해서

241
00:14:00,875 --> 00:14:03,675
이번 수업 마지막까지

242
00:14:03,675 --> 00:14:05,710
이런 알고리즘들이 어떻게

243
00:14:05,710 --> 00:14:08,980
선형 시간에 동작할 수 있는지
배울 것입니다

244
00:14:08,980 --> 00:14:12,310
또는 VE, 즉 정점의 관점으로 보았을 때
세 제곱 시간이 되겠군요

245
00:14:12,310 --> 00:14:17,330
또는 VE, 즉 정점의 관점으로 보았을 때
세 제곱 시간이 되겠군요

246
00:14:17,330 --> 00:14:19,530
그 점 알아두시길 바랍니다

247
00:14:19,530 --> 00:14:23,470
가중치가 있는 그래프를
조금 더 다루어 보겠습니다

248
00:14:23,470 --> 00:14:31,940
표기법을 조금 더
정의하도록 하겠습니다

249
00:14:31,940 --> 00:14:38,170
V0에서 경로 p를 통해
Vk로 간다고 해봅시다

250
00:14:38,170 --> 00:14:40,470
그래서 이렇게 나타내면 V0에서 Vk로 가는

251
00:14:40,470 --> 00:14:43,810
특정한 경로가 있다는 것을 말합니다

252
00:14:43,810 --> 00:14:48,900
최소의 가중치를 갖는 경로
p를 찾는다는 의미도 가집니다

253
00:14:48,900 --> 00:14:51,190
그것을 이렇게 나타내도록 하겠습니다

254
00:14:51,190 --> 00:14:56,120
정점 하나로만 이루어진 경로인 V0는

255
00:14:56,120 --> 00:15:00,580
V0에서 V0로 가는 경로를 의미합니다

256
00:15:00,580 --> 00:15:03,680
길이가 0인 경로이죠

257
00:15:03,680 --> 00:15:07,630
가중치도 0입니다

258
00:15:07,630 --> 00:15:09,410
이건 하나의 상황입니다

259
00:15:09,410 --> 00:15:12,670
우리가 다뤄야 할 또 다른 상황으로

260
00:15:12,670 --> 00:15:18,120
경로가 없는 경우가 있습니다

261
00:15:18,120 --> 00:15:20,820
그래서 이 두 가지 극단적인 상황과

262
00:15:20,820 --> 00:15:23,610
그사이에 존재하는 상황들을 모두 합쳐

263
00:15:23,610 --> 00:15:29,810
최단 경로의 정의를 세울 것입니다

264
00:15:29,810 --> 00:15:33,990
이제 최단 경로를 다룰 것인데

265
00:15:33,990 --> 00:15:38,990
u와 v 사이의 최단 경로의 가중치를

266
00:15:38,990 --> 00:15:43,610
δ(u, v)라고 했을 때
이 δ 값을 찾는 것이 목표입니다

267
00:15:43,610 --> 00:15:45,560
물론 그 경로도 함께 찾습니다

268
00:15:45,560 --> 00:15:48,890
여기서부터 렉싱턴까지 14마일 안에
갈 수 있다는 사실만 알고

269
00:15:48,890 --> 00:15:53,270
여기서부터 렉싱턴까지 14마일 안에
갈 수 있다는 사실만 알고

270
00:15:53,270 --> 00:15:56,830
그 경로를 모른다면
아무런 도움이 되지 않을 것입니다

271
00:15:56,830 --> 00:15:59,690
이런 면이 있기 때문에

272
00:15:59,690 --> 00:16:01,110
가중치만 얻는 것이 아닌

273
00:16:01,110 --> 00:16:02,970
그 경로도 함께 찾을 것입니다

274
00:16:02,970 --> 00:16:06,230
이런 알고리즘들이
그런 역할도 할 것입니다

275
00:16:06,230 --> 00:16:10,150
그리고 특별히 저희가 원하는 것은

276
00:16:10,150 --> 00:16:24,100
δ(u, v)가 모든 경로 p에 대해서 최소인 W(p)입니다

277
00:16:24,100 --> 00:16:30,730
p가 u에서 v까지 가는 경로일 때 말이죠

278
00:16:30,730 --> 00:16:34,106
이는 그런 경로가 존재할 때의 이야기이고

279
00:16:40,490 --> 00:16:44,920
그렇지 않은 경우는 이를 무한대로 설정하고

280
00:16:44,920 --> 00:16:51,295
가중치는 무한대가 됩니다

281
00:16:51,295 --> 00:16:56,490
예를 들어, 육로만을 생각한다면
여기서 도쿄까지의 거리는

282
00:16:56,490 --> 00:16:59,540
무한대가 될 것입니다

283
00:16:59,540 --> 00:17:04,098
사이에 태평양이 존재하기 때문이죠

284
00:17:04,098 --> 00:17:08,970
바로 이 값이 저희가
확인하고 싶은 것입니다

285
00:17:08,970 --> 00:17:11,040
바로 이 값이 저희가
확인하고 싶은 것입니다

286
00:17:11,040 --> 00:17:13,800
특정한 점에서 시작한다고 했을 때

287
00:17:13,800 --> 00:17:18,720
시작점으로부터 최단 경로의 거리는
0이라고 생각할 수 있을 것입니다

288
00:17:18,720 --> 00:17:20,240
시작점으로부터 최단 경로의 거리는
0이라고 생각할 수 있을 것입니다

289
00:17:20,240 --> 00:17:22,150
처음에는 모든 것이 무한이 됩니다

290
00:17:22,150 --> 00:17:24,790
아직 아무런 경로도 찾지 못했기 때문이죠

291
00:17:24,790 --> 00:17:28,450
그리고 저희는 이런 무한을 줄여나갈 것입니다

292
00:17:28,450 --> 00:17:31,970
시작 정점으로부터 도달할 수 있는

293
00:17:31,970 --> 00:17:34,040
모든 정점의 경우에서 말이죠

294
00:17:34,040 --> 00:17:37,580
하지만 주어진 어떤 그래프에서

295
00:17:37,580 --> 00:17:40,740
V 중에서 특정한 시작점에서는

296
00:17:40,740 --> 00:17:44,030
갈 수 없는 정점들이 있을 수도 있습니다

297
00:17:44,030 --> 00:17:45,290
갈 수 없는 정점들이 있을 수도 있습니다

298
00:17:45,290 --> 00:17:50,650
그런 정점들에 대해서 δ(u, v)는

299
00:17:50,650 --> 00:17:56,650
u에서 v까지 도달 불가능하다고 할 때
무한으로 남아있게 될 겁니다

300
00:17:56,650 --> 00:17:59,870
예를 하나 살펴보겠습니다

301
00:18:03,710 --> 00:18:12,980
이 그래프에서 최단 경로를 찾기 위해서
반복적인 작업을 할 것입니다

302
00:18:12,980 --> 00:18:18,150
이 그래프에서 최단 경로를 찾기 위해서
반복적인 작업을 할 것입니다

303
00:18:18,150 --> 00:18:22,100
최단 경로가 쉽게 보이지 않는

304
00:18:22,100 --> 00:18:27,770
상당히 복잡한 그래프를
예로 들어보겠습니다

305
00:18:27,770 --> 00:18:31,330
시작점을 S로 나머지 정점들에는

306
00:18:31,330 --> 00:18:35,420
A에서 F까지의 이름을 붙이겠습니다

307
00:18:35,420 --> 00:18:39,965
그리고 많은 간선이 있습니다

308
00:18:44,780 --> 00:18:48,360
5

309
00:19:06,170 --> 00:19:08,330
여기도 하나 그리겠습니다

310
00:19:10,230 --> 00:19:11,640
이 그래프가 주어졌다고 해봅시다

311
00:19:11,640 --> 00:19:18,720
그리고 이 그래프에서 u가 S이고

312
00:19:18,720 --> 00:19:25,390
v가 A, B, D 등인 δ(u, v)를 찾아보겠습니다

313
00:19:25,390 --> 00:19:30,850
이를 손으로 직접

314
00:19:30,850 --> 00:19:35,111
너비 우선 탐색과
비슷한 방법으로 풀어보겠습니다

315
00:19:35,111 --> 00:19:36,610
너비 우선 탐색과

316
00:19:36,610 --> 00:19:38,060
깊이 우선 탐색은 이미 배웠으니

317
00:19:38,060 --> 00:19:47,030
이 두 개념들로 최단 경로들을
어떻게 찾을지 생각해봅시다

318
00:19:47,030 --> 00:19:48,829
물론 그렇게 구해진 경로가

319
00:19:48,829 --> 00:19:51,370
최단인지는 증명을 해야 하고

320
00:19:51,370 --> 00:19:52,720
그것이 어려운 부분이 될 것입니다

321
00:19:52,720 --> 00:19:56,860
하지만 경로와 관련된 숫자들를 
채워볼 수는 있을 것입니다

322
00:19:56,860 --> 00:19:58,620
이미 알고 있는 선에서 말이죠

323
00:19:58,620 --> 00:20:02,635
정점들 안에 있는 수인 d(u)를

324
00:20:02,635 --> 00:20:08,210
정점들 안에 있는 수인 d(u)를

325
00:20:08,210 --> 00:20:14,075
현재의 가중치라고 정의하겠습니다

326
00:20:14,090 --> 00:20:17,890
그래서 처음에는 d(S)가
0인 것으로부터 시작합니다

327
00:20:17,890 --> 00:20:19,699
시작점이기 때문이죠

328
00:20:19,699 --> 00:20:21,240
그리고 나머지 정점들은

329
00:20:21,240 --> 00:20:23,073
지금 적지는 않겠지만

330
00:20:23,073 --> 00:20:26,940
d(v)의 값으로
무한대를 가지고 있을 것입니다

331
00:20:26,940 --> 00:20:28,350
d(A)가 무한이고

332
00:20:28,350 --> 00:20:31,210
d(B)도 무한인 식으로 말이죠

333
00:20:31,210 --> 00:20:34,500
그리고 여기서 이 d 값들을
줄여나갈 것인데

334
00:20:34,500 --> 00:20:38,080
현재 가중치를 의미하는
정점 안에 있는 모든 d 값들이

335
00:20:38,080 --> 00:20:41,230
현재 가중치를 의미하는
정점 안에 있는 모든 d 값들이

336
00:20:41,230 --> 00:20:44,310
최종적으로는 δ 값이 되도록 할 것입니다

337
00:20:44,310 --> 00:20:48,520
그래서 이 d 값들이 최종적으로

338
00:20:48,520 --> 00:20:52,810
δ 값이 될 때까지 줄였을 때
알고리즘은 끝납니다

339
00:20:52,810 --> 00:20:57,500
그저 경험적으로
반복적으로 시도하면서

340
00:20:57,500 --> 00:21:00,920
이 숫자들을 줄여나갑니다

341
00:21:00,920 --> 00:21:03,860
여기는 무한이었는데

342
00:21:03,860 --> 00:21:08,690
S에서 간선을 타고 오면

343
00:21:08,690 --> 00:21:11,980
여기를 1로 표시할 수 있을 것입니다

344
00:21:11,980 --> 00:21:15,630
그와 비슷하게 여기는
2로 표시할 수 있을 것입니다

345
00:21:15,630 --> 00:21:19,860
그리고 임의로
이 정점 A의 1을 선택해서

346
00:21:19,860 --> 00:21:23,870
그리고 임의로
이 정점 A의 1을 선택해서

347
00:21:23,870 --> 00:21:28,090
A로부터 뻗어 나가는 간선들을 보겠습니다

348
00:21:28,090 --> 00:21:36,470
그러면 예를 들어 여기를
6으로 표시할 수 있을 것입니다

349
00:21:36,470 --> 00:21:42,380
그리고 다시 여기서 시작하면
이쪽을 3으로 표시할 수 있고요

350
00:21:42,380 --> 00:21:48,570
그렇다면 δ(S, C)가
6이 되는 것이 맞을까요?

351
00:21:48,570 --> 00:21:54,670
그렇다면 δ(S, C)가
6이 되는 것이 맞을까요?

352
00:21:54,670 --> 00:21:56,100
아닙니다

353
00:21:56,100 --> 00:22:00,550
그렇다면 C로 가는
더 나은 길이 있나요?

354
00:22:00,550 --> 00:22:02,780
그 가중치는 얼마죠?

355
00:22:02,780 --> 00:22:06,594
어떤 정점들을 지나와야 하나요?

356
00:22:06,594 --> 00:22:19,180
한 가지 방법은
S, B, D, C로 가는 방법이고

357
00:22:19,180 --> 00:22:21,520
가중치는 5가 될 것입니다

358
00:22:21,520 --> 00:22:23,280
그래서 여기는 5입니다

359
00:22:23,280 --> 00:22:26,530
5보다 나은 방법이 있나요?

360
00:22:26,530 --> 00:22:27,770
이 그래프에서는 없네요

361
00:22:27,770 --> 00:22:28,930
네

362
00:22:28,930 --> 00:22:36,680
그래서 거쳐온 정점의 수가 적다고

363
00:22:36,680 --> 00:22:40,980
적은 가중치가 되는 것만은 아닙니다

364
00:22:40,980 --> 00:22:42,600
이 경우가 바로 그 예죠

365
00:22:42,600 --> 00:22:44,600
계속 숫자들을 채우는 지루한 작업을
같이 할 수도 있겠지만

366
00:22:44,600 --> 00:22:45,930
여길 채우는 지루한 작업을
같이 할 수도 있겠지만

367
00:22:45,930 --> 00:22:47,980
각자 해보세요

368
00:22:47,980 --> 00:22:53,020
별로 의미가 있지도 않고요

369
00:22:53,020 --> 00:22:55,660
하지만 δ로 수렴하기 위해서는

370
00:22:55,660 --> 00:22:59,430
어떠한 일들을 해야 하는지
감을 잡을 수 있겠군요

371
00:22:59,430 --> 00:23:01,600
하지만 조금 작업을 해야 할 겁니다

372
00:23:01,600 --> 00:23:06,002
어떻게든 암묵적으로 진행해야 하니까요

373
00:23:06,002 --> 00:23:07,460
명시적으로 하려면

374
00:23:07,460 --> 00:23:10,370
지수적인 경로의 수를
모두 헤아려보아야 합니다

375
00:23:10,370 --> 00:23:12,670
하지만 암묵적으로

376
00:23:12,670 --> 00:23:16,480
한 점으로 갈 수 있는 모든 길을 생각하면서

377
00:23:16,480 --> 00:23:21,790
최단 경로를 찾겠죠

378
00:23:21,790 --> 00:23:22,490
최단 경로를 찾겠죠

379
00:23:22,490 --> 00:23:25,080
그 일들을 최단 경로 알고리즘에서
해야 합니다

380
00:23:25,080 --> 00:23:26,510
그 일들을 최단 경로 알고리즘에서
해야 합니다

381
00:23:26,510 --> 00:23:31,290
이것이 음이 아닌 가중치를 갖는

382
00:23:31,290 --> 00:23:34,160
단순 그래프에서의 예제였습니다

383
00:23:34,160 --> 00:23:38,599
음의 가중치를 갖게 된다면
더 복잡해질 것입니다

384
00:23:38,599 --> 00:23:40,640
하지만 그 전에

385
00:23:40,640 --> 00:23:43,490
실제 경로를 찾는 방법에 대해서
다루어 보겠습니다

386
00:23:43,490 --> 00:23:46,900
실제 경로를 찾는 방법에 대해서
다루어 보겠습니다

387
00:23:46,900 --> 00:23:49,935
여기서 한 일은

388
00:23:49,935 --> 00:23:55,890
최단 경로의 가중치인
δ(u, v)를 찾는 일이지만

389
00:23:55,890 --> 00:24:00,080
실제 경로를 알아내고 싶으면

390
00:24:00,080 --> 00:24:04,090
최소 가중치를 갖는 정점들의
나열을 찾는 방법이 필요합니다

391
00:24:04,090 --> 00:24:08,310
최소 가중치를 갖는 정점들의
나열을 찾는 방법이 필요합니다

392
00:24:08,310 --> 00:24:10,240
그래서 선행 관계라는 것을
정의하겠습니다

393
00:24:10,240 --> 00:24:16,290
그래서 선행 관계라는 것을
정의하겠습니다

394
00:24:16,290 --> 00:24:25,270
원 안에 있던 값인 d(V)는

395
00:24:25,270 --> 00:24:34,900
현재의 가중치를 의미합니다

396
00:24:34,900 --> 00:24:38,400
이 d 값이 저희의 관심 대상이고

397
00:24:38,400 --> 00:24:40,270
최종적으로는 δ 값이 되기를 원합니다

398
00:24:40,270 --> 00:24:42,330
다른 관심 있는 대상은

399
00:24:42,330 --> 00:24:45,950
굉장히 분명한 자료 구조입니다

400
00:24:45,950 --> 00:24:50,050
각각은 d 값과
선행 정점의 값에 해당합니다

401
00:24:50,050 --> 00:24:50,910
각각은 d 값과
선행 정점의 값에 해당합니다

402
00:24:50,910 --> 00:25:06,820
∏[v]는 v까지의 최선의 경로에서
바로 직전 정점입니다

403
00:25:06,820 --> 00:25:13,480
∏[S]는 존재하지 않겠죠

404
00:25:13,490 --> 00:25:15,950
이것이 최종적으로
저희가 원하는 것이 될 것이고

405
00:25:15,950 --> 00:25:20,600
마찬가지로 계속 수정이 되겠죠

406
00:25:20,600 --> 00:25:24,720
그래서 경로를 찾기 위한
시도들을 할 때

407
00:25:24,720 --> 00:25:27,320
현재에서 최선인 경로를 얻게 될 것인데

408
00:25:27,320 --> 00:25:29,500
현재에서 최선인 경로를 얻게 될 것인데

409
00:25:29,500 --> 00:25:31,930
그는 선행 정점들을 계속해서 따라가며

410
00:25:31,930 --> 00:25:34,550
얻어낼 수 있는 정점의 나열일 것입니다

411
00:25:34,550 --> 00:25:40,250
특정 정점 E에 왔을 때

412
00:25:40,250 --> 00:25:46,700
∏[E]를 보고 그 값이
C를 가리키고 있을 때

413
00:25:46,700 --> 00:25:49,190
∏[E]를 보고 그 값이
C를 가리키고 있을 때

414
00:25:49,190 --> 00:25:52,240
다시 ∏[C] 값을 보면
A를 가리키게 되겠죠

415
00:25:52,240 --> 00:25:54,320
이런 방식으로요

416
00:25:54,320 --> 00:25:57,560
이 예제에서 ∏[E]는

417
00:25:57,560 --> 00:26:02,470
최종적으로 완료했을 때 A를 가리키게 될 것이고

418
00:26:02,470 --> 00:26:06,150
∏[A]는 S를 가리키게 될 것입니다

419
00:26:06,150 --> 00:26:10,010
이는 이것이 최선의 경로이기 때문입니다

420
00:26:10,010 --> 00:26:12,660
이런 식으로요

421
00:26:12,660 --> 00:26:14,380
그래서 이 두 자료 구조가

422
00:26:14,380 --> 00:26:18,200
반복을 할 때 생각해야 하는 것들입니다

423
00:26:18,200 --> 00:26:24,970
선행 관계와 현재 거리를 말이죠

424
00:26:24,970 --> 00:26:29,340
그리고 d가 δ가 되면 끝납니다

425
00:26:29,340 --> 00:26:31,370
그리고 d가 δ가 되면 끝납니다

426
00:26:31,370 --> 00:26:33,401
그리고 그 시점에서
선행 관계가 완성되게 됩니다

427
00:26:33,401 --> 00:26:37,150
그리고 그 시점에서
선행 관계가 완성되게 됩니다

428
00:26:37,150 --> 00:26:39,842
이렇게 구성되어 있습니다

429
00:26:39,842 --> 00:26:41,800
그리고 마지막으로 복잡한 조건을 하나 추가하자면

430
00:26:41,800 --> 00:26:44,284
음의 가중치입니다

431
00:26:44,284 --> 00:26:46,450
벨만-포드가 여기에 적혀 있을 때
이야기하는 것이 낫겠죠

432
00:26:46,450 --> 00:26:53,460
벨만-포드가 여기에 적혀 있을 때
이야기하는 것이 낫겠죠

433
00:26:53,467 --> 00:27:00,390
조금 더 일반화된 알고리즘입니다

434
00:27:00,410 --> 00:27:09,190
첫 번째 물음은 왜 이런 알고리즘이 존재해서

435
00:27:09,190 --> 00:27:11,780
저희의 삶을 복잡하게 만드냐는 것입니다

436
00:27:11,780 --> 00:27:14,380
저희의 삶을 복잡하게 만드냐는 것입니다

437
00:27:14,380 --> 00:27:15,780
예시를 하나 들어드리겠습니다

438
00:27:15,780 --> 00:27:22,335
왜 음의 가중치를 갖는
그래프가 필요한 것일까요?

439
00:27:22,335 --> 00:27:23,990
정말로 알고 싶군요

440
00:27:23,990 --> 00:27:26,450
가장 필요한 이유 정도는
언급할 가치가 있을 것 같습니다

441
00:27:26,450 --> 00:27:28,980
다음 시간에도 그 예제를
사용할 수 있도록요

442
00:27:28,980 --> 00:27:29,863
네, 말씀하세요

443
00:27:29,863 --> 00:27:35,286
학생: 만약 어떤 목표를 설정하는데

444
00:27:35,286 --> 00:27:40,708
학생: 목표를 이루고자 비용을 지불해야 하는 경우와

445
00:27:40,709 --> 00:27:42,188
학생: 목표를 이루고자 비용을 지불해야 하는 경우와

446
00:27:42,188 --> 00:27:45,392
학생: 비용을 받는 경우가 있을 때

447
00:27:45,392 --> 00:27:52,960
학생: 어떠한 경로로 가야 가장 효율적일지

448
00:27:55,279 --> 00:27:56,485
네, 그거 괜찮은 이유가 될 것 같군요

449
00:27:56,485 --> 00:28:02,755
네, 그거 괜찮은 이유가 될 것 같군요

450
00:28:02,755 --> 00:28:04,980
운전에서의 거리를 생각해보면

451
00:28:04,980 --> 00:28:07,530
음의 거리는 아무런 의미가 없죠

452
00:28:07,530 --> 00:28:09,820
적어도 물리적으로는요

453
00:28:09,820 --> 00:28:13,652
하지만 돈을 받고 운전을 하는 경우를
상상해 볼 수 있겠군요

454
00:28:13,652 --> 00:28:15,110
하지만 돈을 받고 운전을 하는 경우를
상상해 볼 수 있겠군요

455
00:28:15,110 --> 00:28:18,325
하지만 돈을 받고 운전을 하는 경우를
상상해 볼 수 있겠군요

456
00:28:18,325 --> 00:28:18,950
네, 말씀하세요

457
00:28:18,950 --> 00:28:20,366
학생: 부루마불 같은 경우를 생각해보면

458
00:28:20,366 --> 00:28:24,014
학생: 정점을 각 도시라고 생각해서

459
00:28:24,014 --> 00:28:25,680
어떤 도시에 도착했을 때

460
00:28:25,680 --> 00:28:26,570
돈을 지불한다든지

461
00:28:26,570 --> 00:28:28,060
아니면 어떤 도시에 도착했을 때

462
00:28:28,060 --> 00:28:29,010
돈을 받는 경우가 있겠군요

463
00:28:29,010 --> 00:28:29,926
학생:

464
00:28:32,792 --> 00:28:34,750
앞과 뒤로 가는 경우요
맞습니다

465
00:28:34,750 --> 00:28:35,458
네, 말하세요

466
00:28:35,458 --> 00:28:36,374
학생:

467
00:28:43,710 --> 00:28:46,670
흥미로운 생각을 하셨네요

468
00:28:46,670 --> 00:28:49,230
어떤 곳을 가고 싶을 때

469
00:28:49,230 --> 00:28:52,080
지금 말하는 이 경우에서

470
00:28:52,080 --> 00:28:55,490
그 거리 기준을 이용하면 더 돌아가는 길이
더 나을 수도 있다는 말이군요

471
00:28:55,490 --> 00:28:59,940
그 거리 기준을 이용하면 더 돌아가는 길이
더 나을 수도 있다는 말이군요

472
00:28:59,940 --> 00:29:01,190
그 거리 기준을 이용하면 더 돌아가는 길이
더 나을 수도 있다는 말이군요

473
00:29:01,190 --> 00:29:02,106
학생:

474
00:29:08,380 --> 00:29:09,160
네, 맞습니다

475
00:29:09,160 --> 00:29:09,659
네, 맞습니다

476
00:29:09,659 --> 00:29:10,290
좋은 방법이네요

477
00:29:10,290 --> 00:29:10,820
좋은 방법이네요

478
00:29:10,820 --> 00:29:12,103
네, 저기 손드신 분

479
00:29:12,103 --> 00:29:12,728
학생: 네

480
00:29:12,728 --> 00:29:15,223
학생: 고속도로를 예로 들어보자면

481
00:29:15,223 --> 00:29:18,217
학생: 이런 경우에 음이라고
생각할 수 있을 것 같습니다

482
00:29:18,217 --> 00:29:22,209
학생: 만약에 정부에서
교통량을 조절하기 위해서

483
00:29:22,209 --> 00:29:26,201
학생: 통행료를 이용한다고 하면
음의 거리로 작용하지 않을까요

484
00:29:26,201 --> 00:29:28,696
학생: 왜나하면 당연하지만, 그 길에서

485
00:29:28,696 --> 00:29:31,582
학생: 통행료를 빼면
0보다 작을 수 있기 때문이죠

486
00:29:31,582 --> 00:29:32,290
좋은 예인 것 같네요

487
00:29:32,290 --> 00:29:35,120
좋은 예인 것 같네요

488
00:29:35,120 --> 00:29:37,050
저희가 생각해보아야 할 한 가지는

489
00:29:37,050 --> 00:29:39,310
아마 연습 문제나 퀴즈에서
마주칠 수도 있겠지만

490
00:29:39,310 --> 00:29:43,620
아마 연습 문제나 퀴즈에서
마주칠 수도 있겠지만

491
00:29:43,620 --> 00:29:48,540
모든 가중치가 양수가 되도록
조정하는 방법이 있을까요?

492
00:29:48,540 --> 00:29:52,250
저희가 이야기해 보았던 예들은
어떤 점에서는 명확하지 않았는데

493
00:29:52,250 --> 00:29:56,100
몇몇 상황은 가중치를 음으로 두지 않고

494
00:29:56,100 --> 00:29:59,130
몇몇 상황은 가중치를 음으로 두지 않고

495
00:29:59,130 --> 00:30:03,120
0을 기반으로 하도록
만들 수 있었을 것 같습니다

496
00:30:03,120 --> 00:30:07,370
특정 상황에서는
적용되지 않을 수도 있지만

497
00:30:07,370 --> 00:30:09,630
제가 이 이야기를 하는 이유는
그렇게 할 수 있다면

498
00:30:09,630 --> 00:30:12,200
제가 이 이야기를 하는 이유는
그렇게 할 수 있다면

499
00:30:12,200 --> 00:30:14,760
O(VE) 알고리즘을
사용하는 것이 아닌

500
00:30:14,760 --> 00:30:18,120
그렇게 구한 답이
처음에 주어진 문제의 답과

501
00:30:18,120 --> 00:30:20,630
같다는 것만 증명할 수 있다면

502
00:30:20,630 --> 00:30:23,360
O(V logV) 알고리즘을
사용할 수 있을 것입니다

503
00:30:23,360 --> 00:30:24,894
O(V logV) 알고리즘을
사용할 수 있을 것입니다

504
00:30:24,894 --> 00:30:26,310
그렇게 복잡도를 줄일 수 있겠죠

505
00:30:26,310 --> 00:30:28,160
그 점을 기억해두세요

506
00:30:28,160 --> 00:30:30,720
문제를 바꾸지 않고 음의 가중치를
없앨 수 있는지 시도해보세요

507
00:30:30,720 --> 00:30:32,730
문제를 바꾸지 않고 음의 가중치를
없앨 수 있는지 시도해보세요

508
00:30:32,730 --> 00:30:34,080
네, 뒤에 손드신 분

509
00:30:34,080 --> 00:30:35,056
학생: 아뇨

510
00:30:35,056 --> 00:30:37,008
학생: 그렇게 만들 수 있는지
질문하시는 줄 알았어요

511
00:30:37,008 --> 00:30:37,984
학생: 그렇게 만들 수 있는지
질문하시는 줄 알았어요

512
00:30:37,984 --> 00:30:41,400
학생: 대답하려고 손들었습니다

513
00:30:41,400 --> 00:30:47,540
네, 아무튼 그 점을 기억해두세요

514
00:30:47,540 --> 00:30:49,956
저번 시간에 강의할 때
들었었던 예가 하나 있네요

515
00:30:49,956 --> 00:30:51,330
저번 시간에 강의할 때
들었었던 예가 하나 있네요

516
00:30:51,330 --> 00:30:54,620
운전을 하고 있는데 광고가
여기저기 있다고 상상해보세요

517
00:30:54,620 --> 00:30:56,240
운전을 하고 있는데 광고가
여기저기 있다고 상상해보세요

518
00:30:56,240 --> 00:30:58,750
그 길을 지날 때 돈을 받는다고 했었죠

519
00:30:58,750 --> 00:31:00,197
통행료의 반대죠

520
00:31:00,197 --> 00:31:02,530
그 길을 가려면
광고를 봐야 해서 역 통행료입니다

521
00:31:02,530 --> 00:31:04,940
그 길을 가려면
광고를 봐야 해서 역 통행료입니다

522
00:31:04,940 --> 00:31:09,200
광고를 보지 않고
빠르게 지나가려고 할 것 같지만

523
00:31:09,200 --> 00:31:11,380
어쨌든 지나가야 합니다

524
00:31:11,380 --> 00:31:14,690
그런 특정한 길을 지나가면
돈을 받는다는 예가 있었습니다

525
00:31:14,690 --> 00:31:16,810
SNS는 어떤가요?

526
00:31:16,810 --> 00:31:19,550
좋아요랑 싫어요 같은 것들이 있죠

527
00:31:19,550 --> 00:31:22,037
각각 양과 음으로
생각될 수 있지 않나요?

528
00:31:22,037 --> 00:31:23,870
SNS가 양의 가중치와 음의 가중치를
갖는다고 해석할 수 있습니다

529
00:31:23,870 --> 00:31:26,190
SNS가 양의 가중치와 음의 가중치를
갖는다고 해석할 수 있습니다

530
00:31:26,190 --> 00:31:27,750
저는 페이스북 계정을 가지고 있지 않지만
여러분들은 가지고 있죠

531
00:31:27,750 --> 00:31:29,250
저는 페이스북 계정을 가지고 있지 않지만
여러분들은 가지고 있죠

532
00:31:29,250 --> 00:31:32,240
저는 페이스북 계정을 가지고 있지 않지만
여러분들은 가지고 있죠

533
00:31:32,240 --> 00:31:36,154
어떤 것이 무엇을 의미하는지

534
00:31:36,154 --> 00:31:37,570
아니, 저는 어떻게 동작하는지 잘 모르니

535
00:31:37,570 --> 00:31:40,410
여러분들이 잘 생각해보시길 바랍니다

536
00:31:40,410 --> 00:31:41,240
여러분들이 잘 생각해보시길 바랍니다

537
00:31:41,240 --> 00:31:43,060
역 통행료, SNS

538
00:31:47,080 --> 00:31:47,770
많은 것들이 있죠

539
00:31:51,040 --> 00:31:53,140
이런 예들이 이해가 안 되더라도

540
00:31:53,140 --> 00:31:56,589
강의 하나에 걸쳐
벨만-포드에 대해 배울 것입니다

541
00:31:56,589 --> 00:31:57,880
아시겠나요

542
00:32:01,020 --> 00:32:04,470
음의 사이클과 관련된 문제들은 중요하니

543
00:32:04,470 --> 00:32:07,780
조금 이야기해 보도록 하겠습니다

544
00:32:07,780 --> 00:32:09,780
경로가 지수적인 수만큼 존재해서

545
00:32:09,780 --> 00:32:13,100
경로가 지수적인 수만큼 존재해서

546
00:32:13,100 --> 00:32:15,820
문제가 된다고 말했었는데

547
00:32:15,820 --> 00:32:18,610
양의 가중치만 있을 때조차도 그랬었습니다

548
00:32:18,610 --> 00:32:20,420
그 예제를 다시 한번 볼 것입니다

549
00:32:20,420 --> 00:32:22,970
하지만 음의 사이클이 있을 때는
더 심각한 문제가 있습니다

550
00:32:22,970 --> 00:32:26,955
하지만 음의 사이클이 있을 때는
더 심각한 문제가 있습니다

551
00:32:29,449 --> 00:32:30,990
언젠가는 알고리즘이 끝나게 될 텐데

552
00:32:30,990 --> 00:32:32,860
더 빠르게 끝날 수록

553
00:32:32,860 --> 00:32:35,850
점근적인 복잡도에 대해 말할 수 있다면

554
00:32:35,850 --> 00:32:38,100
당연하지만, 최악의 경우보다
빠르게 끝났다는 것을 의미합니다

555
00:32:38,100 --> 00:32:41,160
당연하지만, 최악의 경우보다
빠르게 끝났다는 것을 의미합니다

556
00:32:41,160 --> 00:32:43,680
그리고 만약 그게 지수적이라면
안 좋을 것입니다

557
00:32:43,680 --> 00:32:45,040
그래서 그것이 작기를 원하죠

558
00:32:45,040 --> 00:32:47,310
하지만 아예 끝나지 않는다면?

559
00:32:47,310 --> 00:32:52,610
이런 그래프가 있다고 합시다

560
00:32:52,610 --> 00:33:02,400
몇몇 간선은 음의 가중치를 갖습니다

561
00:33:02,400 --> 00:33:04,140
몇몇 간선은 음의 가중치를 갖습니다

562
00:33:04,140 --> 00:33:05,840
나머지는 양수이고요

563
00:33:05,840 --> 00:33:07,025
여기는 -6입니다

564
00:33:17,380 --> 00:33:20,060
다 맞는 것 같군요

565
00:33:20,060 --> 00:33:26,520
2, 4, -6, 3, 2, 1, -2

566
00:33:26,520 --> 00:33:28,500
이 그래프에서
알 수 있는 점 중 하나는

567
00:33:28,500 --> 00:33:33,700
여기에 거슬리는 사이클이
있다는 점입니다

568
00:33:33,700 --> 00:33:35,710
음의 사이클이죠

569
00:33:35,710 --> 00:33:38,130
이 예제를 선택한 이유가 그것입니다

570
00:33:38,130 --> 00:33:39,860
-6 더하기 2는 -4이고

571
00:33:39,860 --> 00:33:41,910
-4에 3을 더하면 -1입니다

572
00:33:41,910 --> 00:33:45,680
그래서 만약에 이런 상황처럼

573
00:33:45,680 --> 00:33:50,870
d가 계속 줄어들다가

574
00:33:50,870 --> 00:33:53,120
결국 멈춘다는 사실을
이용할 수 없게 된다면

575
00:33:53,120 --> 00:33:53,870
네, 물론

576
00:33:53,870 --> 00:33:55,286
양의 가중치 또는 음의 가중치를
가진 간선만 있으면

577
00:33:55,286 --> 00:33:57,350
모든 가중치가 0 이상이기 때문에

578
00:33:57,350 --> 00:34:00,470
언젠가는 멈추게 될 것입니다

579
00:34:00,470 --> 00:34:01,290
언젠가는 멈추게 될 것입니다

580
00:34:01,290 --> 00:34:05,940
하지만 음의 사이클이 존재하는 그래프라면

581
00:34:05,940 --> 00:34:08,969
이런 경우가 무한 루프를
만들어 낼 것입니다

582
00:34:08,969 --> 00:34:10,980
이는 프로그램에서 버그가 될 수 있겠죠

583
00:34:10,980 --> 00:34:14,380
구현상의 버그는 아닐지라도

584
00:34:14,380 --> 00:34:15,750
알고리즘상에서의 버그가 될 것입니다

585
00:34:15,750 --> 00:34:19,415
왜냐하면 종료 조건이
제대로 설정되지 않기 때문입니다

586
00:34:19,415 --> 00:34:20,790
B에 왔다고 해봅시다

587
00:34:20,790 --> 00:34:24,100
B에 왔다고 해봅시다

588
00:34:24,100 --> 00:34:26,860
여기 가중치를 빠뜨렸군요

589
00:34:26,860 --> 00:34:32,909
그래서 B에 도착했을 때 δ(S, B)는
4라고 말할 수 있을까요?

590
00:34:32,909 --> 00:34:36,739
그래서 B에 도착했을 때 δ(S, B)는
4라고 말할 수 있을까요?

591
00:34:36,739 --> 00:34:37,576
아닙니다

592
00:34:37,576 --> 00:34:39,659
왜냐하면 여기서 한 바퀴를 돌아

593
00:34:39,659 --> 00:34:41,853
다시 B에 오면 가중치는 3이 됩니다

594
00:34:41,853 --> 00:34:44,020
이렇게 한 번 더 하면 가중치는 2가 되고

595
00:34:44,020 --> 00:34:45,540
계속 돌 수 있겠죠

596
00:34:45,540 --> 00:34:46,989
이것이 문제입니다

597
00:34:46,989 --> 00:34:49,050
그러면 알고리즘이
어떻게 동작해야 할까요?

598
00:34:49,050 --> 00:34:52,719
벨만-포드 알고리즘은
이걸 어떻게 다룰까요?

599
00:34:52,719 --> 00:34:56,855
이 그래프에서 모든 δ 값에 대해서
최단 거리가 정의되지 않는 것은 아닙니다

600
00:34:56,855 --> 00:34:58,230
이 그래프에서 모든 δ 값에 대해서
최단 거리가 정의되지 않는 것은 아닙니다

601
00:34:58,230 --> 00:35:00,210
이 그래프에서 모든 δ 값에 대해서
최단 거리가 정의되지 않는 것은 아닙니다

602
00:35:00,210 --> 00:35:03,410
몇몇은 잘 정의됩니다

603
00:35:03,410 --> 00:35:05,440
이 점에서는 다시 돌아올 길이 없으므로

604
00:35:05,440 --> 00:35:10,040
확실하게 δ(S, S)는 0이라고
말할 수 있습니다

605
00:35:10,040 --> 00:35:12,150
모두 이해되나요?

606
00:35:12,150 --> 00:35:14,610
여기는 어떨까요?

607
00:35:14,610 --> 00:35:16,640
2겠죠

608
00:35:16,640 --> 00:35:21,120
δ(S, A)는 2입니다

609
00:35:21,132 --> 00:35:23,340
모두 동의하시죠
다른 길이 없기 때문입니다

610
00:35:23,340 --> 00:35:25,560
음의 사이클에 닿고 있지 않기 때문입니다

611
00:35:25,560 --> 00:35:27,750
음의 가중치를 갖는 간선을 통하지도 않고요

612
00:35:27,750 --> 00:35:34,970
더 중요한 것은 A로 가는
음의 사이클이 없다는 거죠

613
00:35:34,970 --> 00:35:38,970
한편 여기에 있는 정점들은

614
00:35:38,970 --> 00:35:40,870
이 사이클을 여러 번 돌아

615
00:35:40,870 --> 00:35:44,430
원하는 가중치를 얻을 수도 있겠죠

616
00:35:44,430 --> 00:35:46,940
음의 무한대 가중치라든지요

617
00:35:46,940 --> 00:35:48,680
그래서 알고리즘이

618
00:35:48,680 --> 00:35:51,770
이런 음의 사이클을
처리할 수 있어야 합니다

619
00:35:51,770 --> 00:35:53,400
까다로운 부분일 것입니다

620
00:35:53,400 --> 00:35:55,590
음의 가중치를 가지는 간선 자체는

621
00:35:55,590 --> 00:35:58,960
한 번 이상 갈 수 없다면
별로 어려운 점은 아닐 겁니다

622
00:35:58,960 --> 00:36:01,450
음의 사이클이 어려운 점이죠

623
00:36:01,450 --> 00:36:03,500
그리고 이런 음의 사이클이

624
00:36:03,500 --> 00:36:08,330
최단 거리를 정의할 수 없게 만듭니다

625
00:36:08,330 --> 00:36:12,940
하지만 모든 정점이 그렇지는 않습니다

626
00:36:12,940 --> 00:36:14,800
이 점에서의 경우가 그렇죠

627
00:36:14,800 --> 00:36:17,600
그래서 벨만-포드 알고리즘

628
00:36:17,600 --> 00:36:20,730
또는 최단 경로 알고리즘이

629
00:36:20,730 --> 00:36:23,390
음의 사이클을 다루기 위해서는

630
00:36:23,390 --> 00:36:25,810
합리적인 시간 안에
종료될 수 있어야 합니다

631
00:36:25,810 --> 00:36:28,930
여기서는 O(VE)가 되겠죠

632
00:36:28,930 --> 00:36:33,540
그리고 유한의 값을 갖는
정점들의 δ를 찾고

633
00:36:33,540 --> 00:36:37,290
그리고 유한의 값을 갖는
정점들의 δ를 찾고

634
00:36:37,290 --> 00:36:39,150
나머지 정점들은 정할 수 없거나
음의 무한대라고 표시해주어야 합니다

635
00:36:39,150 --> 00:36:43,720
나머지 정점들은 미결정 또는
음의 무한대라고 표시해야 합니다

636
00:36:43,720 --> 00:36:45,560
그것이 종료 조건입니다

637
00:36:45,560 --> 00:36:47,770
음의 가중치가 없을 때의
경우와는 다릅니다

638
00:36:47,770 --> 00:36:50,900
음의 가중치가 없을 때의
경우와는 다릅니다

639
00:36:50,900 --> 00:36:55,750
그래서 간선이 아니고
사이클이 문제가 되고

640
00:36:55,750 --> 00:36:57,230
그래서 간선이 아니고
사이클이 문제가 되고

641
00:36:57,230 --> 00:37:00,250
그 사이클에 특별한 처리를
해야 한다는 것을 기억하세요

642
00:37:00,250 --> 00:37:03,210
계산 부분 전체가 바뀌지는 않겠지만요

643
00:37:03,210 --> 00:37:06,890
그런 사이클이 있는지 없는지
알 수 없다면

644
00:37:06,890 --> 00:37:12,180
벨만-포드 알고리즘을 이용해야 할 것입니다

645
00:37:12,180 --> 00:37:14,750
이 점이 이야기하는 흥미로운 점은

646
00:37:14,750 --> 00:37:18,400
벨만-포드 알고리즘이 
음의 사이클을 감지해야 한다는거죠

647
00:37:18,400 --> 00:37:20,880
벨만-포드가 음의 사이클을 발견하지 못하면

648
00:37:20,880 --> 00:37:23,310
임의의 경우에 대해서
올바른 알고리즘이라고 할 수 없겠죠

649
00:37:23,310 --> 00:37:25,090
임의의 경우에 대해서
올바른 알고리즘이라고 할 수 없겠죠

650
00:37:25,090 --> 00:37:27,380
다익스트라는 그런 처리를
할 필요가 없기 때문에

651
00:37:27,380 --> 00:37:29,450
더 간단할 수 있는 것입니다

652
00:37:29,450 --> 00:37:30,720
그렇습니다

653
00:37:30,720 --> 00:37:36,820
최단 경로 알고리즘의 일반적인
구조에 대해서 이야기해 보겠습니다

654
00:37:36,820 --> 00:37:37,600
최단 경로 알고리즘의 일반적인
구조에 대해서 이야기해 보겠습니다

655
00:37:37,600 --> 00:37:42,750
두 가지 중요한 개념에 대해
짚고 넘어갈 것인데

656
00:37:42,750 --> 00:37:49,030
하나는 완화 과정에 대한 것입니다

657
00:37:49,030 --> 00:37:51,590
이미 예제들을 다루면서
간단하게 해보았지만

658
00:37:51,590 --> 00:37:53,460
엄밀하게 정의해보겠습니다

659
00:37:53,460 --> 00:37:59,465
그리고 그 정의를 이용해
지수적인 그래프 예제를 다뤄보겠습니다

660
00:37:59,465 --> 00:38:03,965
그리고 그 정의를 이용해
지수적인 그래프 예제를 다뤄보겠습니다

661
00:38:03,980 --> 00:38:06,650
최단 경로 알고리즘의
기본적인 구조는 다음과 같습니다

662
00:38:06,650 --> 00:38:09,260
최단 경로 알고리즘의
기본적인 구조는 다음과 같습니다

663
00:38:09,260 --> 00:38:16,470
간선 집합에 있는 모든 u에 대하여

664
00:38:16,470 --> 00:38:20,380
d[v]를 무한대로 초기화합니다

665
00:38:20,380 --> 00:38:26,260
그리고 선행자를 NIL로 설정하고

666
00:38:26,260 --> 00:38:31,650
d[S]를 0으로 초기화합니다

667
00:38:31,650 --> 00:38:33,400
출발점이 한 곳일 때의 이야기입니다

668
00:38:33,400 --> 00:38:35,800
그것을 0으로 정합니다

669
00:38:35,800 --> 00:38:41,270
기본적으로 반복적인 작업을 할 것입니다

670
00:38:45,110 --> 00:38:54,240
임의의 간선 (u, v)를 선택합니다
선택하는 방법은 아직 정하지 않았습니다

671
00:38:54,240 --> 00:38:56,560
이를 어떻게 정하냐에 따라

672
00:38:56,560 --> 00:38:58,640
다른 알고리즘이 만들어지게 됩니다

673
00:38:58,640 --> 00:39:07,430
하지만 중요한 점은 간선 (u, v)를
완화할 것이라는 점입니다

674
00:39:07,430 --> 00:39:11,980
여기서 완화라는 것은

675
00:39:11,980 --> 00:39:14,140
그 간선을 봤을 때

676
00:39:14,140 --> 00:39:21,880
d[v]가 d[u] + w(u, v)보다 크다는 것은

677
00:39:21,880 --> 00:39:33,610
v로 가는 기존의 방법보다
더 나은 방법을 찾았다는 것입니다

678
00:39:33,610 --> 00:39:36,100
d[v]가 지금은 무한대겠죠

679
00:39:36,100 --> 00:39:39,020
아직 v로 가는 방법을 찾지 않았기 때문입니다

680
00:39:39,020 --> 00:39:43,110
하지만 d[u]가 유한수인 것을 알고

681
00:39:43,110 --> 00:39:45,840
u에서 v로 가는 간선이
존재하는 것을 알기 때문에

682
00:39:45,840 --> 00:39:48,910
d[v]의 값을 갱신할 수 있습니다

683
00:39:48,910 --> 00:39:53,550
이 과정을 간선 (u, v)의
완화 과정이라고 부릅니다

684
00:39:53,550 --> 00:39:57,710
그래서 여기서 하는 것은
이 조건문이 참일 때

685
00:39:57,710 --> 00:40:05,770
d[v]를 d[u] + w(u, v)로
설정하는 것입니다

686
00:40:05,770 --> 00:40:09,570
그리고 선행 관계도 갱신해야겠죠

687
00:40:09,570 --> 00:40:16,430
현재 v의 최단 선행자는

688
00:40:16,430 --> 00:40:17,826
u가 되기 때문입니다

689
00:40:17,826 --> 00:40:20,900
이 과정을 완화라고 부릅니다

690
00:40:20,900 --> 00:40:23,880
지금 여기 공간이 부족하지만

691
00:40:23,880 --> 00:40:26,930
이 과정을 계속해서 되풀이합니다

692
00:40:26,930 --> 00:40:28,010
이 과정을 계속해서 되풀이합니다

693
00:40:28,010 --> 00:40:30,525
언제까지 반복할까요?

694
00:40:30,525 --> 00:40:42,110
반복은 모든 간선이

695
00:40:42,110 --> 00:40:56,860
d[v]가 d[u] + w(u, v)보다
작거나 같아질 때 끝납니다

696
00:40:56,860 --> 00:41:01,940
여기서 가정하는 것은 음의 사이클이
없어야 한다는 것입니다

697
00:41:01,940 --> 00:41:05,020
다른 구조가 필요합니다

698
00:41:05,020 --> 00:41:07,840
완화라는 개념은 유효하겠지만

699
00:41:07,840 --> 00:41:11,650
하지만 이와 똑같은 구조가

700
00:41:11,650 --> 00:41:14,940
벨만-포드나 음의 사이클을 처리할 수 있는
다른 알고리즘에 사용되지는 않습니다

701
00:41:14,940 --> 00:41:19,580
벨만-포드나 음의 사이클을 처리할 수 있는
다른 알고리즘에 사용되지는 않습니다

702
00:41:19,580 --> 00:41:23,370
완화라는 개념을 이해했길 바랍니다

703
00:41:23,370 --> 00:41:26,580
그림을 이용해서 보면

704
00:41:26,580 --> 00:41:29,420
완화는 저희가 했던 일들입니다

705
00:41:29,420 --> 00:41:35,150
이 값을 6에서 5로 갱신했을 때의
과정을 예로 한번 보겠습니다

706
00:41:35,150 --> 00:41:39,840
이 값을 6에서 5로 갱신했을 때의
과정을 예로 한번 보겠습니다

707
00:41:39,840 --> 00:41:42,970
이 간선에 대해 완화한다고 해봅시다
d는 이미 갱신이 된 상태고요

708
00:41:42,970 --> 00:41:47,230
이 정점의 d가 3이라고 하고

709
00:41:47,230 --> 00:41:49,450
이 정점은 원래 6이었다고 해봅시다

710
00:41:49,450 --> 00:41:53,620
이 정점을 봤을 때 d[C]가 6인 것이죠

711
00:41:53,620 --> 00:41:58,530
한편으로 6은 d[D]인 3과

712
00:41:58,530 --> 00:42:03,060
w(D, C)인 2를 더한 값보다 큽니다

713
00:42:03,060 --> 00:42:06,370
5가 6보다 작기 때문에
이 간선에 대해 완화할 수 있고

714
00:42:06,370 --> 00:42:09,610
이 값을 6에서 5로
갱신할 수 있는 것이죠

715
00:42:09,610 --> 00:42:12,690
그리고 선행 관계를 갱신합니다

716
00:42:12,690 --> 00:42:18,300
∏[C]를 D로요

717
00:42:18,300 --> 00:42:19,460
이것이 완화의 개념입니다

718
00:42:19,460 --> 00:42:20,610
기본이 되는 개념이고

719
00:42:20,610 --> 00:42:24,860
앞으로 이야기할 모든 알고리즘에서
사용될 것입니다

720
00:42:24,860 --> 00:42:26,530
알고리즘이 언제 끝나게 될까요?

721
00:42:26,530 --> 00:42:28,480
음의 사이클이 없는 경우에는

722
00:42:28,480 --> 00:42:32,740
꽤 명확한 종료 조건이 있습니다

723
00:42:32,740 --> 00:42:35,940
어떤 간선에 대해서도
완화가 불가능할 때이죠

724
00:42:35,940 --> 00:42:39,040
이 과정을 계속하다 보면

725
00:42:39,040 --> 00:42:41,430
각 정점 안에 적힌 값들을

726
00:42:41,430 --> 00:42:43,170
각 정점 안에 적힌 값들을

727
00:42:43,170 --> 00:42:45,150
어떠한 간선을 선택하더라도

728
00:42:45,150 --> 00:42:47,580
갱신할 수 없는 때가 올 것입니다

729
00:42:47,580 --> 00:42:50,820
그래서 이 종료 조건은

730
00:42:50,820 --> 00:42:54,271
O(E)번 확인하는 작업이 필요합니다

731
00:42:54,271 --> 00:42:55,770
아직 효율이라는 의미에서의 복잡도를
이야기하는 것은 아니지만

732
00:42:55,770 --> 00:42:59,190
아직 효율이라는 의미에서의 복잡도를
이야기하는 것은 아니지만

733
00:42:59,190 --> 00:43:03,040
모든 간선에 대해 완화될 수 없다고
이야기하기 위해서는

734
00:43:03,040 --> 00:43:05,720
모든 간선에 대해
확인해 보아야 할 것입니다

735
00:43:05,720 --> 00:43:07,740
만약 하나라도 완화될 수 있다면

736
00:43:07,740 --> 00:43:11,480
그로 인해 다른 것도
완화될 수 있습니다

737
00:43:11,480 --> 00:43:13,800
그래서 모든 간선에 대해
완화될 수 없을 때까지 반복해야 합니다

738
00:43:13,800 --> 00:43:17,610
그래서 모든 간선에 대해
완화될 수 없을 때까지 반복해야 합니다

739
00:43:17,610 --> 00:43:20,040
완전 탐색 알고리즘이죠

740
00:43:20,040 --> 00:43:21,420
느리겠지만 잘 동작할 것입니다

741
00:43:21,420 --> 00:43:23,720
느리겠지만 잘 동작할 것입니다

742
00:43:23,720 --> 00:43:26,110
알려진 음의 사이클에 대해서는
동작할 것입니다

743
00:43:26,110 --> 00:43:29,290
간선을 임의로 선택하는 과정을
계속하며 진행하면 됩니다

744
00:43:29,290 --> 00:43:31,340
간선을 임의로 선택하는 과정을
계속하며 진행하면 됩니다

745
00:43:31,340 --> 00:43:36,880
하지만 이가 나쁘게 작동하는 예가 있는데
잠시 후에 살펴보도록 하겠습니다

746
00:43:36,880 --> 00:43:38,340
그래도 이것은 알고리즘입니다

747
00:43:38,340 --> 00:43:40,030
알고리즘을 안 다루겠다고 한 것이
거짓말이 되어버렸군요

748
00:43:40,030 --> 00:43:42,270
알고리즘을 안 다루겠다고 한 것이
거짓말이 되어버렸군요

749
00:43:42,270 --> 00:43:43,150
네, 이것은 알고리즘입니다

750
00:43:43,150 --> 00:43:47,150
다만 별로 구현하고 싶은
알고리즘은 아니네요

751
00:43:47,150 --> 00:43:49,940
완화를 하는 조건은 구현할 만 하겠지만

752
00:43:49,940 --> 00:43:55,130
간선을 무작위로 선택하고

753
00:43:55,130 --> 00:43:58,470
O(E)번 종료 조건을 확인하는 작업은
별로 구현하고 싶지 않겠죠

754
00:43:58,470 --> 00:44:01,770
O(E)번 종료 조건을 확인하는 작업은
별로 구현하고 싶지 않겠죠

755
00:44:01,770 --> 00:44:03,490
이 알고리즘을 지양해야 하는 이유는

756
00:44:03,490 --> 00:44:06,080
잠시 후에 볼 지수적 그래프 예제를 통해
알게 될 것입니다

757
00:44:06,080 --> 00:44:08,710
잠시 후에 볼 지수적 그래프 예제를 통해
알게 될 것입니다

758
00:44:08,710 --> 00:44:12,530
모두 따라오고 있나요?

759
00:44:12,530 --> 00:44:15,040
기본적인 구조와 완화 과정에
대한 질문 있나요?

760
00:44:15,040 --> 00:44:18,156
기본적인 구조와 완화 과정에
대한 질문 있나요?

761
00:44:18,156 --> 00:44:19,870
다음으로 넘어가도 되나요?

762
00:44:19,870 --> 00:44:20,550
좋아요

763
00:44:20,550 --> 00:44:24,050
제가 강의를 끝내고

764
00:44:24,050 --> 00:44:26,320
여러분들 모두 잘 이해한
환상적인 강의를 했다고 생각했는데

765
00:44:26,320 --> 00:44:27,170
여러분들 모두 잘 이해한
환상적인 강의를 했다고 생각했는데

766
00:44:27,170 --> 00:44:29,320
나중에 조교가 연습반에서

767
00:44:29,320 --> 00:44:32,260
나중에 조교가 연습반에서

768
00:44:32,260 --> 00:44:34,050
그래프가 뭔지 이해했냐고 물었는데

769
00:44:34,050 --> 00:44:36,130
아니라고 한다든지

770
00:44:36,130 --> 00:44:37,810
어떤 것에 대해 이해했냐는 질문에

771
00:44:37,810 --> 00:44:38,850
아니라고 답하는 건 아니겠죠?

772
00:44:38,850 --> 00:44:43,460
그러니 조교한테는 
이해했다고 이야기해주세요

773
00:44:43,460 --> 00:44:45,840
이해했든지 말든지요!

774
00:44:45,840 --> 00:44:47,090
제가 안심할 수 있도록 말이죠

775
00:44:47,090 --> 00:44:49,774
학생: 제 삶도 편해지겠군요

776
00:44:49,774 --> 00:44:51,680
그렇죠

777
00:44:51,680 --> 00:44:53,030
좋아요

778
00:44:53,030 --> 00:44:55,540
여러분들은 저보다 조교에게 
이야기 듣는 걸 더 좋아하겠죠

779
00:44:55,540 --> 00:44:56,470
여러분들은 저보다 조교에게
이야기 듣는 걸 더 좋아하겠죠

780
00:44:56,470 --> 00:44:59,690
모두 그렇게 생각하죠?

781
00:45:02,770 --> 00:45:05,010
네 그래서
이 알고리즘을 구현하는 것이

782
00:45:05,010 --> 00:45:09,380
별로 좋지 않은 생각인 이유는

783
00:45:09,380 --> 00:45:12,850
다음에 볼 예제 같은 경우가
있기 때문입니다

784
00:45:12,850 --> 00:45:16,120
제가 이 예제를 좋아하는 이유는

785
00:45:16,120 --> 00:45:20,540
이 예제가 두 가지 다른 점을
보여주기 때문입니다

786
00:45:20,540 --> 00:45:24,670
이 예제가

787
00:45:24,670 --> 00:45:27,840
그래프에 지수적으로
많은 경로가 있는 경우에

788
00:45:27,840 --> 00:45:29,864
이 알고리즘이 문제가
될 수 있다는 것을 보여줍니다

789
00:45:29,864 --> 00:45:31,280
그리고 이 예제가 보여주는
또 다른 문제로는

790
00:45:31,280 --> 00:45:35,590
간선의 가중치와 관련된 문제입니다

791
00:45:35,590 --> 00:45:39,480
이전에 발견했던 것들 중에

792
00:45:39,480 --> 00:45:42,560
이런 알고리즘들이

793
00:45:42,560 --> 00:45:45,760
가변적인 가중치의 범위에 상관없이
작동한다는 것이 있었습니다

794
00:45:45,760 --> 00:45:48,480
그래서 지수적인 범위의
가중치가 있다고 해보겠습니다

795
00:45:48,480 --> 00:45:50,970
그래서 지수적인 범위의
가중치가 있다고 해보겠습니다

796
00:45:50,970 --> 00:45:55,220
4가 지수적이지는 않지만
어떻게 보면

797
00:45:55,220 --> 00:45:57,500
1과 2랑 지수적인 관계에
있다고 할 수 있겠죠

798
00:45:57,500 --> 00:45:59,980
1과 2랑 지수적인 관계에
있다고 할 수 있겠죠

799
00:45:59,980 --> 00:46:02,390
여기서 말하고 싶은 점은

800
00:46:02,390 --> 00:46:13,940
이렇게 생긴 그래프를 만들었다고 하고

801
00:46:13,940 --> 00:46:20,390
이런 규칙을 가지고 가중치를 설정한다면

802
00:46:20,390 --> 00:46:23,270
마지막은 2^(n/2)와 같은 가중치를
가질 것입니다

803
00:46:23,270 --> 00:46:29,000
마지막은 2^(n/2)와 같은 가중치를
가질 것입니다

804
00:46:29,000 --> 00:46:30,700
이 그래프에 n개의
정점이 있다고 하면요

805
00:46:30,700 --> 00:46:33,060
아니면 적어도 이들 가중치의 범위가

806
00:46:33,060 --> 00:46:35,730
2^(n/2)까지가 될 것입니다

807
00:46:35,730 --> 00:46:39,720
이해하시나요?

808
00:46:39,720 --> 00:46:43,600
그래서 이 그래프를 엄청 큰 그래프의
일부분이라고 생각하세요

809
00:46:43,600 --> 00:46:46,380
예를 들어 n이 100이면
가중치는 2의 50제곱인 식으로요

810
00:46:46,380 --> 00:46:48,380
예를 들어 n이 100이면
가중치는 2의 50제곱인 식으로요

811
00:46:48,380 --> 00:46:49,920
2의 50제곱은 컴퓨터에서
다룰 수 없을 정도의 수는 아닙니다

812
00:46:49,920 --> 00:46:51,780
2의 50제곱은 컴퓨터에서
다룰 수 없을 정도의 수는 아닙니다

813
00:46:51,780 --> 00:46:53,720
64비트보다 작습니다

814
00:46:53,720 --> 00:46:56,250
충분히 합리적인 예죠

815
00:46:56,250 --> 00:46:59,190
예전에 다중 정밀도와 무한 정밀도에
대해 이야기했었죠

816
00:46:59,190 --> 00:47:00,440
예전에 다중 정밀도와 무한 정밀도에
대해 이야기했었죠

817
00:47:00,440 --> 00:47:02,520
그래서 저희는 임의의 정밀도를 가지는
임의의 수를 다룰 수 있을 것입니다

818
00:47:02,520 --> 00:47:05,030
그래서 저희는 임의의 정밀도를 가지는
임의의 수를 다룰 수 있을 것입니다

819
00:47:05,030 --> 00:47:07,940
그래서 제곱근을 구하는 등의
연산을 수행하는데

820
00:47:07,940 --> 00:47:11,280
아무런 문제가 없을 것입니다

821
00:47:11,280 --> 00:47:12,990
허수는 다루지 않을 것이고요

822
00:47:12,990 --> 00:47:15,790
그래서 특정한 그래프의
가중치에 어떠한 수를 넣어도

823
00:47:15,790 --> 00:47:20,140
그래서 특정한 그래프의
가중치에 어떠한 수를 넣어도

824
00:47:20,140 --> 00:47:22,870
모든 가중치가 음이 아니라면
다익스트라가 잘 작동해야 할 것입니다

825
00:47:22,870 --> 00:47:28,090
모든 가중치가 음이 아니라면
다익스트라가 잘 작동해야 할 것입니다

826
00:47:28,090 --> 00:47:30,760
그럼 이 예제는
어떤 문제가 있는 것일까요?

827
00:47:30,760 --> 00:47:33,090
이 예제에서는 이런 문제가 발생합니다

828
00:47:33,090 --> 00:47:36,340
이 알고리즘을 실행한다고 해보죠

829
00:47:36,340 --> 00:47:42,210
이 사슬을 따라가면서요

830
00:47:42,210 --> 00:47:45,320
처음 여기는 0으로 시작할 것입니다

831
00:47:45,320 --> 00:47:48,530
여기는 4로 도달할 수 있기 때문에
4가 될 것입니다

832
00:47:48,530 --> 00:47:50,280
여기는 8이고

833
00:47:50,280 --> 00:47:51,650
여기는 10이 되고

834
00:47:51,650 --> 00:47:57,920
여기는 각각 12, 13, 14가
될 것입니다

835
00:47:57,930 --> 00:48:00,740
이것이 첫 단계일 것입니다

836
00:48:00,740 --> 00:48:02,990
이렇게 간선이 선택될 것입니다

837
00:48:02,990 --> 00:48:10,020
그러면 여기 14를
완화할 수 있게 됩니다

838
00:48:10,020 --> 00:48:11,430
그러면 여기 14를
완화할 수 있게 됩니다

839
00:48:11,430 --> 00:48:13,660
이 간선에 대해 완화한다고 해보죠

840
00:48:13,660 --> 00:48:18,940
12와 14가 있기 때문에
13으로 바꿉니다

841
00:48:18,940 --> 00:48:25,030
이 간선에 대해 완화한다면
여기가 12로 바뀌게 됩니다

842
00:48:25,030 --> 00:48:27,640
이 과정을 반복합니다

843
00:48:27,640 --> 00:48:30,510
여기는 12로 유지되고

844
00:48:30,510 --> 00:48:32,560
이제 이 간선에 대해 완화합니다

845
00:48:32,560 --> 00:48:35,350
그러면 이 12가 10이 됩니다

846
00:48:35,350 --> 00:48:37,310
여기가 바뀌면

847
00:48:37,310 --> 00:48:41,830
먼저 이 간선에 대해 완화한다면

848
00:48:41,830 --> 00:48:45,060
여기 13이
11이 됩니다

849
00:48:45,060 --> 00:48:46,440
여기가 11이 되어도
별 상관없습니다

850
00:48:46,440 --> 00:48:49,450
여기가 11이 되어도
별 상관없습니다

851
00:48:49,450 --> 00:48:51,281
이게 맞나요?

852
00:48:51,281 --> 00:48:51,780
네

853
00:48:51,780 --> 00:48:55,690
이게 11이고
여기도 11이 됩니다

854
00:48:55,690 --> 00:48:57,440
여기가 12였을 수도 있겠죠

855
00:48:57,440 --> 00:48:59,250
이 두 간선에 대해 먼저 완화했다면요

856
00:48:59,250 --> 00:49:02,920
그 후에 12에서 11이 되고
이런 식으로요

857
00:49:02,920 --> 00:49:07,450
그래서 경로의 순서에 따라
장황하게 설명하지는 않겠지만

858
00:49:07,450 --> 00:49:09,700
14, 13, 12, 11처럼 줄어들 수도 있습니다

859
00:49:09,700 --> 00:49:14,480
좋지 않은 순서로
간선을 선택한다면 말이죠

860
00:49:14,480 --> 00:49:16,990
좋지 않은 순서로
간선을 선택한다면 말이죠

861
00:49:16,990 --> 00:49:21,266
처음 시작할 때 여기 가중치는

862
00:49:21,266 --> 00:49:22,640
처음 시작할 때 여기 가중치는

863
00:49:22,640 --> 00:49:25,390
O(2^(n/2))가 될 것입니다

864
00:49:25,390 --> 00:49:29,160
이 특정한 그래프에 대해서는

865
00:49:29,160 --> 00:49:32,640
종료하기까지 지수적인 수의
간선 완화를 해야 한다는 것이죠

866
00:49:32,640 --> 00:49:36,940
종료하기까지 지수적인 수의
간선 완화를 해야 한다는 것이죠

867
00:49:36,940 --> 00:49:39,840
간선 완화를 해야 되는 횟수가

868
00:49:39,840 --> 00:49:42,440
처음에 시작했던 가중치만큼이
된다는 것입니다

869
00:49:42,440 --> 00:49:43,820
처음에 시작했던 가중치만큼이
된다는 것입니다

870
00:49:43,820 --> 00:49:47,220
이 점이 이 알고리즘을
지수 시간 알고리즘으로 만듭니다

871
00:49:47,220 --> 00:49:49,050
이거보다는 더 잘해야 될 것입니다

872
00:49:49,050 --> 00:49:52,540
다익스트라나 벨만-포드에서는요

873
00:49:52,540 --> 00:49:54,840
그러면 어떻게 해야 개선할 수 있을까요?

874
00:49:54,840 --> 00:49:56,260
네, 뒤에 질문

875
00:49:56,260 --> 00:49:57,718
학생: 그러면 그 문제가

876
00:49:57,718 --> 00:50:01,407
학생: 저희가 가장 오른쪽에서부터 완화를….

877
00:50:01,407 --> 00:50:04,140
네, 맞습니다

878
00:50:04,140 --> 00:50:07,410
저희가 간선을 선택한 순서에
문제가 있었던 것이죠

879
00:50:07,410 --> 00:50:10,920
그래서 저희가 보여야 할 것은
어떠한 그래프에 대해서도

880
00:50:10,920 --> 00:50:12,790
선택하는 순서에 상관없이

881
00:50:12,790 --> 00:50:16,910
V logV + E가 되는 것을 보여야 하죠

882
00:50:16,910 --> 00:50:17,910
네 정확합니다

883
00:50:17,910 --> 00:50:20,118
선택하는 순서와 관련된 문제입니다

884
00:50:20,118 --> 00:50:22,050
경로의 순서입니다

885
00:50:22,050 --> 00:50:23,850
저희가 어떻게 선택을 할지

886
00:50:23,850 --> 00:50:27,080
신중해야 한다는 것입니다

887
00:50:27,080 --> 00:50:30,040
잘못된 선택을 한다면
문제가 발생하겠죠

888
00:50:30,040 --> 00:50:32,110
그래서 다음 주 수업에서는

889
00:50:32,110 --> 00:50:35,360
어떻게 하면 간선을 올바르게
선택할 수 있는지 배울 것입니다

890
00:50:35,360 --> 00:50:41,270
그와 관련해서 마지막으로
아주 간단한 개념 하나 보겠습니다

891
00:50:41,270 --> 00:50:44,200
최적 부분 구조를

892
00:50:44,200 --> 00:50:46,430
각각 한 줄로 증명되는 매우 간단한 정리
두 개를 통해 알아보겠습니다

893
00:50:46,430 --> 00:50:50,200
각각 한 줄로 증명되는 매우 간단한 정리
두 개를 통해 알아보겠습니다

894
00:50:50,200 --> 00:50:59,410
첫 번째 정리는
최단 경로의 부분 경로는

895
00:50:59,410 --> 00:51:05,520
최단 경로가 된다는 것입니다

896
00:51:05,520 --> 00:51:11,920
이가 의미하는 바는
V0가 있고 V1으로 가고

897
00:51:11,920 --> 00:51:15,500
또 V2로 갔다고 하면
각각은 경로가 됩니다

898
00:51:15,500 --> 00:51:22,930
각각 p01, p02, p03라고 합시다

899
00:51:22,930 --> 00:51:26,240
V0와 V1 사이에는
많은 정점이 있을 수 있겠죠

900
00:51:26,240 --> 00:51:30,010
여기서 V0에서 V3로 가는 경로가

901
00:51:30,010 --> 00:51:34,460
다시 말해 p01, p02, p03의 연결이

902
00:51:34,460 --> 00:51:38,435
최단 경로라는 것을 안다면

903
00:51:40,740 --> 00:51:44,110
이것이 최단 경로 SP라고 한다면

904
00:51:44,110 --> 00:51:50,030
각각의 경로도 최단 경로라는 것입니다

905
00:51:50,030 --> 00:51:52,650
이는 말이 되죠

906
00:51:52,650 --> 00:51:57,490
만약에 V0에서 V1으로 가는
p01보다 더 나은 길이 있다면

907
00:51:57,490 --> 00:52:00,200
왜 애초에 여기에 p01을 두나요?

908
00:52:00,200 --> 00:52:02,390
그 더 나은 길을 가는 것이 낫죠

909
00:52:02,390 --> 00:52:03,580
정말 간단하죠

910
00:52:03,580 --> 00:52:06,810
이것이 최적 부분 구조라는 성질입니다

911
00:52:06,810 --> 00:52:12,190
삼각 부등식이라는 개념도

912
00:52:12,190 --> 00:52:14,440
이와 연관됩니다

913
00:52:14,440 --> 00:52:21,700
이런 길들이 있고

914
00:52:21,700 --> 00:52:28,110
V0, V1, V2가 있을 때

915
00:52:28,110 --> 00:52:32,810
(V0, V1)의 δ 값을

916
00:52:32,810 --> 00:52:38,500
(V0, V2)와 (V2, V1)의
δ 값과 비교하면

917
00:52:38,500 --> 00:52:46,290
이것이 이 둘을 더한 것보다
작거나 같아야 한다는 것입니다

918
00:52:46,290 --> 00:52:48,096
이것이 이 둘을 더한 것보다
작거나 같아야 한다는 것입니다

919
00:52:48,096 --> 00:52:49,220
이것도 말이 되죠

920
00:52:49,220 --> 00:52:54,090
왜냐면 이 둘을 더한 것이
이거보다 작았다면

921
00:52:54,090 --> 00:52:59,030
간선이 아닌 경로를 이야기
하고 있다는 것을 기억해주세요

922
00:52:59,030 --> 00:53:00,890
V1까지 가는 더 나은 길이

923
00:53:00,890 --> 00:53:03,140
V2를 거쳐가는 길이 된다는 것이죠

924
00:53:03,140 --> 00:53:05,640
이 위 길을 따라가는 것이 아니고요

925
00:53:05,640 --> 00:53:07,480
놀랍게도 이 두 개념이

926
00:53:07,480 --> 00:53:09,670
이 알고리즘을

927
00:53:09,670 --> 00:53:12,980
선형 시간 알고리즘으로
바꾸는데 충분합니다

928
00:53:12,980 --> 00:53:15,530
다음 시간에 해보도록 하죠
